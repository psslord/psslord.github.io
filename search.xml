<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Days-of-22-9</title>
      <link href="/2022/09/01/Day-on-Day/"/>
      <url>/2022/09/01/Day-on-Day/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-9-1"><a href="#2022-9-1" class="headerlink" title="2022-9-1"></a>2022-9-1</h1><p>备战二级（假的，真的为被当出气筒被训个半小时，从下午5点到晚上8点半，属实有点恶心！</p><hr><style>hr:nth-of-type(1) {  border-color: cyan !important;  border-style: dotted!important;}</style><h1 id="2022-9-2"><a href="#2022-9-2" class="headerlink" title="2022-9-2"></a>2022-9-2</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>9点40开始复习二级，重要知识点总结如下:<br>空格：\0  换行：\n  回车：\r    \：\\   ‘：\‘    “：\“   ?：\?<br>input函数输入后为字符串，可用eval函数去掉最外面的引号。<br>print函数输入格式为print(*object,sep=’ ‘,end=’\n’)，其中sep为间隔格式</p><p>十进制 二进制：0b或0B，八进制：0o或0O，十六进制：0x或0X<br>科学计数法：0.004表示为4e-3；round函数：round（x，d）对x进行四舍五入，x表示保留的小数<br>数学操作符：+-*/（加减乘除）整数除（//：结果保留整数）余数（%：结果保留余数），幂运算（**）</p><p>[m:n:k]对字符按照步长k进行切片<br>format()函数：‘输出模板’.format(参数)<br><img src="/2022/09/01/Day-on-Day/1.png" alt="槽-1"><br>槽{&lt;序号&gt;:&lt;填充字符&gt;&lt;对齐方式&gt;&lt;输出列宽&gt;&lt;,&gt;&lt;.精度&gt;&lt;类型&gt;}<br>{0:=^20,.b}:位置+填充+对齐（&lt; \^ &gt;)+宽度+逗号（千位分隔符）+.（精度）+类型<br>其中类型e（科学计数法e），E（科学计数法E），f（浮点数），%（百分数）<br><img src="/2022/09/01/Day-on-Day/2.png" alt="槽-2"><br>判断一个字符是否为数字：’0’&lt;=c&lt;=’9’;判断一个字符是否为汉字：’\u0e00’&lt;=c&lt;=’\u9fa5’<br>判断一个字符是否为字母：’a’&lt;=c&lt;=’z’ or ‘A’&lt;=c&lt;=’Z’<br>双分支紧凑模式：k=’合格’  if s&gt;=60 else ‘不合格’<br>遍历循环： for &lt;循环变量&gt; in &lt;遍历结构&gt;：<br>无限循环：while<br>判断数字：isnumeric(),   判断字符：isalpha() 返回True或者False<br>循环后的else可被当为正常完成循环的一个奖励<br>turtle库：<img src="/2022/09/01/Day-on-Day/3.png" alt="turtle"></p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>干活找设备资料（🐂🐴）</p><hr><style>hr:nth-of-type(2) {  border-color: cyan !important;  border-style: dotted!important;}</style><h1 id="2022-9-3"><a href="#2022-9-3" class="headerlink" title="2022-9-3"></a>2022-9-3</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><p>过去拍设备图，因周末没有上班</p><h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2><p>二级继续复习！！🤗🤗<br>‘’.join(a):对字符串a中的元素按照sep拼接在一起，只适用于字符串<br>a.strip():去除字符两端的空格<br>a.split():按照sep分割字符<br>d.keys():键的信息<br>d.values():值的信息<br>d.ltems():键值对的信息，使用时需要使用list转化为列表<br>d.get(k,\<default>):键k存在则返回相应值。不存在则返回\<default><br>sorted(ss,reverse=True)不改变源列表的值<br>ls.sort(key=lambad x:x[1],reverse=True)改变源列表的值<br>set()建立集合，集合内没有重复元素，集合是无序的<br>文件路名不能直接用\,需要\\或者/、//<br>write(str(ls)):write函数只能写入字符串<br>jieba库：jieba.lcut(s)</default></default></p><hr><style>hr:nth-of-type(3) {  border-color: cyan !important;  border-style: dotted!important;}</style><h1 id="2022-9-4"><a href="#2022-9-4" class="headerlink" title="2022-9-4"></a>2022-9-4</h1><p>python二级考试复习！！！ヾ(≧▽≦*)o\</p><p>random库：产生伪随机数<br>seed():随机种子<br>random():[0,1)中的随机小数<br>randint(a,b):[a,b]中随机整数<br>uniform(a,b):[a,b]中随机小数<br>randrange(m,n[,k]):生成一个[m,n]以k为步长的随机整数<br>sample(pop,k):返回pop类型中随机选取k个元素构成的列表<br>choice(sep):从序列中随机选择一个元素<br>shuffle(sep):将序列sep中元素随机排列，返回打乱后的序列<br>time库：<br>时间获取：time():返回时间戳，浮点数，以秒为单位, ctime()：返回字符串, localtime()<br>时间格式化：strftime()：格式化时间显示<br>程序计时：perf_counter(), sleep()<br>PyInstaller库：将python源代码打包生成可执行的exe程序<br>Pyinstaller  -F koch.py  - i  snow.ico生成build文件夹作为临时文件夹，dist文件夹作为目标文件夹<br>数据分析：Numpy, Pandas, SciPy<br>数据可视化：Matplotlib, Seaborn, Mayavi(三位数据可视化功能库)<br>机器学习：Scikit-learn, TensorFlow, MXnet<br>网络爬虫：Requests, Scrapy, Pyspider<br>网站开发：Django, Pyramid, Flask ,Tornado, TimeSide    Django &gt;Pyramid&gt;Flask<br>文本处理：Beautifulsoup4, SnowNLP, openpyxi<br>用户图形界面：PyQt5, wxpython, pygtk<br>游戏开发：Pygame, panda3d, Cocos2d<br>all(x):x元素全为真时返回True,，无参数返回True， any(x)：x任一元素为真时返回True，无参数返回False<br>zip()函数，将对象中对应的元素打包成一个个元组<br>id()函数：返回对象的内存地址,是一个正整数<sup><a href="#fn_1" id="reffn_1">1</a></sup><br><sup><a href="#fn_1" id="reffn_1">1</a></sup>: </p><h2 id="刷题记录"><a href="#刷题记录" class="headerlink" title="刷题记录"></a>刷题记录</h2><p>第一范式：数据表中的字段都是单一属性，不可再分</p><p>数据流图（DFD）构造规则：数据流图中，数据流指暂时保存的数据，它可以是数据库文件或任何形式的数据组织，数据存储间不应该有数据流；数据流图中除了流向数据存储或从数据存储流出的数据不必命名外，每个数据流必须要有一个合适的名字，以反映该数据流的含义；相邻两层DFD之间具有父、子关系，子图代表了父图中某个加工的详细描述，父图表示了子图间的接口。子图个数不大于父图中的处理个数。所有子图的输入、输出数据流和父图中相应处理的输入、输出数据流必须一致。</p><p>扇出：是指该模块直接调用下级模块的个数</p><p>扇入：是指该模块被直接调用的个数</p><hr><style>hr:nth-of-type(4) {  border-color: cyan !important;  border-style: dotted!important;}</style><h1 id="2022-9-5"><a href="#2022-9-5" class="headerlink" title="2022-9-5"></a>2022-9-5</h1><p>上午拍摄设备图片，下午追剧（感觉有点罪恶），不过也重新思考了一下人生，皆是棋子，属来无趣！！！</p><p>有点感触，也就谈谈吧！天下熙熙，皆为利来，天下攘攘，皆为利往！成年人的世界里就只有自己，也只剩下自己。我慢慢地懂了为啥以前文人雅客那么追求棋艺了，棋局中各个棋子相互制衡，各有所用，在不同的位置上发挥着不同的作用。通过棋局的对弈，对弈者总会试着攻击对方的弱点从而取得整局的胜利。人们常说，人生如棋，可在我看来，应是棋如人生才对。一场棋局总会有个正式的开始和结束，可人生这场棋我们常常身陷棋局中而不自知，被人当作棋子却不自省，到头来，空悲切，一场空。要上位，就得必须为上面的人做些符合他们利益的一些事，可有些事一旦做了，便留下了一生的把柄在别人手上了。我时常会问自己，若有一天，我面临如此困境，我应当如何选择？我不知道我那时会怎么选，也没有心理答案。好像不管怎么选都会有愚蠢的一段时间，有的是一阵子，有的是一辈子。算了算了，空想太多了，所有的焦虑都是源于没有实际的行动，所以干就完了。</p><hr><p><style><br>hr:nth-of-type(5) {<br>  border-color: cyan !important;<br>  border-style: dotted!important;<br>}</style></p><h1 id="2022-9-7"><a href="#2022-9-7" class="headerlink" title="2022-9-7"></a>2022-9-7</h1><p>错题记录：</p><p>数据库设计：概念设计、逻辑设计和建立数据库</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活、记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习之RNN</title>
      <link href="/2022/07/30/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8BRNN/"/>
      <url>/2022/07/30/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8BRNN/</url>
      
        <content type="html"><![CDATA[<p>这里我展示了RNN及相关变体的主要理论以及我自己理解的一些点，欢迎大家留言探讨。</p><p>先简单介绍一下我与RNN及其变体的一些渊源。我是2021年7月12号换的研究方向，之前一直在研究摩擦纳米发电，苦于没有实验条件，也没有师兄师姐请教，为了顺利毕业，只能换了方向。随后我跟着一位张师兄搞负荷预测，开始接触机器学习以及深度学习。因为负荷预测是一个时序回归问题，所以当时首选的就是在时序问题上有着较好性能的LSTM模型（RNN模型的一种变体，后续会详细介绍其理论），从这开始，我与机器学习以及深度学习的缘分算是开始了……</p><!-- more  --><h1 id="RNN（循环神经网络）"><a href="#RNN（循环神经网络）" class="headerlink" title="RNN（循环神经网络）"></a>RNN（循环神经网络）</h1><p>神经网络就好像一个黑匣子函数，它通过模型在训练集上的训练来确定内部神经元之间的权重，从而在输入和输出之间建立一条映射关系。通过添加激活函数等方法使得这一映射关系不再是传统的非线性映射关系。然而传统的人工神经网络只能拟合单个x和y之间映射关系，即输入多个x，它能按照训练好的模型拟合输出多个x相对应的y。这一功能很是强大，在理论上，传统的人工神经网络模型能够拟合数学上绝大多数函数。然而，在我们的现实生活中，始终有着一条时间线存在的。就是因为这一时间线的存在，让我们的输入X并不是单一独立的各个x1，x2….。在x1，x2之间还存在一定的时序关系（又或者说因果关系），即前一时刻的x1会对后一时刻的x2的输出y2有着一定的影响，简单来说x1也是x2的输出的影响因数之一。当考虑到这种情况，用传统的人工神经网络来处理这种时序问题就显得不那么合理了。当然，在人工神经网络中，我们可以手动地把x1添加到x2的自变量中，但是这一操作会引申出一个实际问题：当我们实际应用人工神经网络模型来处理时序问题时，我们应该添加多少个前一时刻的x值到当前x的模型输入中去呢？添加的数量多了会让真正影响当前x的自变量在所有自变量的权重降低，从而对模型精度会造成很大的影响；添加的量少了会让x的时序关系体现的不够充分，也会造成模型精度的下降。如何添加前一时刻的x值不仅将严重依赖研究人员的经验，也会因为所解决的问题不同显著增加研究人员的研究难度。因此，我们需要一个在模型原理上就已经考虑到时序关系的模型来解决具体的时序问题。这时，RNN（循环人工神经网络）就应运而生了。</p><h2 id="RNN理论"><a href="#RNN理论" class="headerlink" title="RNN理论"></a>RNN理论</h2><p>RNN由一个输入层，一个隐藏层和一个输出层组成，其原理图如图1所示：<img src="/2022/07/30/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8BRNN/RNN.jpg" alt="RNN" title="图1：RNN"></p><p>其中，<script type="math/tex">x_t</script>代表当前时刻的输入，<script type="math/tex">S_t</script>代表当前时刻隐藏层的值，<script type="math/tex">O_t</script>代表当前时刻的输出值。值得注意的是，<script type="math/tex">S_t</script>的值不仅取决于<script type="math/tex">x_t</script>，还与<script type="math/tex">S_{t-1}</script>有关。</p><script type="math/tex; mode=display">O_t=g(V \cdot S_t) \\S_t=f(U \cdot X_t+W \cdot S_{t-1})</script><p>式中，输出层是一个全连接层，<script type="math/tex">V</script>是输出层的权重矩阵，<script type="math/tex">g</script>是激活函数；循环层中，<script type="math/tex">U</script>是输入<script type="math/tex">x</script>权重矩阵，<script type="math/tex">W</script>是上一次<script type="math/tex">S_{t-1}</script>在<script type="math/tex">x</script>上的权重矩阵，<script type="math/tex">f</script>是激活函数。</p><h2 id="RNN带来的问题"><a href="#RNN带来的问题" class="headerlink" title="RNN带来的问题"></a>RNN带来的问题</h2><p>梯度爆炸：误差梯度在网络训练时被用来得到网络参数更新的方向和幅度，进而在正确的方向上以合适的幅度更新网络参数。在深层网络或递归神经网络中，误差梯度在更新中累积得到一个非常大的梯度，这样的梯度会大幅度更新网络参数，进而导致网络不稳定。在极端情况下，权重的值变得特别大，以至于结果会溢出（NaN值，<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/nan/7455322%3Ffr%3Daladdin">无穷与非数值</a>）。当梯度爆炸发生时，网络层之间反复乘以大于1.0的梯度值使得梯度值成倍增长。</p><p>梯度消失：在神经网络中，当前面隐藏层的学习速率低于后面隐藏层的学习速率，即随着隐藏层数目的增加，分类准确率反而下降了。这种现象叫做消失的梯度问题。</p><h1 id="LSTM（长短时记忆神经网络）"><a href="#LSTM（长短时记忆神经网络）" class="headerlink" title="LSTM（长短时记忆神经网络）"></a>LSTM（长短时记忆神经网络）</h1>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习，RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习之决策树(一)：算法原理及实例</title>
      <link href="/2022/07/25/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2022/07/25/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了加强自身有关机器学习理论基础，现重新梳理一下机器学习主流算法的理论知识以及其实践细节。现在分别整理如下：</p><ul><li>决策树</li><li>随机森林</li><li>Adaboost</li><li>GBDT</li><li>logistic回归</li><li>SVM</li><li>朴素贝叶斯</li><li>XGboost</li><li>lightgbm</li></ul><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树是一个有监督分类与回归算法。决策树的生成只考虑局部最优，相对的，决策树剪枝则考虑全局最优。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>决策树是一种基本的分类与回归方法，其模型就是用一棵树来表示我们的整个决策过程。这棵树可以是二叉树（比如CART 只能是二叉树），也可以是多叉树（比如 ID3、C4.5 可以是多叉树或二叉树）。根节点包含整个样本集，每个叶节都对应一个决策结果（注意，不同的叶节点可能对应同一个决策结果），每一个内部节点都对应一次决策过程或者说是一次属性测试。从根节点到每个叶节点的路径对应一个判定测试序列。<br>决策树的生成就是不断的选择最优的特征对训练集进行划分，是一个递归的过程。递归返回的条件有三种：</p><ol><li>当前节点包含的样本属于同一类别，无需划分；</li><li>当前属性集为空，或所有样本在属性集上取值相同，无法划分；</li><li>当前节点包含样本集合为空，无法划分。</li></ol><hr><h2 id="ID3、C4-5、CART基础公式"><a href="#ID3、C4-5、CART基础公式" class="headerlink" title="ID3、C4.5、CART基础公式"></a>ID3、C4.5、CART基础公式</h2><p>这是三个非常著名的决策树算法，简单来说：</p><ul><li>ID3 使用信息增益作为选择特征的准则；</li><li>C4.5 使用信息增益比作为选择特征的准则；</li><li>CART 使用 Gini 指数作为选择特征的准则。</li></ul><h3 id="熵-entropy"><a href="#熵-entropy" class="headerlink" title="熵(entropy)"></a>熵(entropy)</h3><p>表示随机变量不确定性的度量。<br>设X 是一个有限状态的离散型随机变量，其概率分布为:<br>$P(X=x_i)=p_i,\,\,i=1,2,\cdot,n$</p><p>则随机变量X熵定义为:</p><script type="math/tex; mode=display">H(X)=-\sum_{i=1}^np_i*log(p_i)</script><p>熵越大，则随机变量的不确定性越大。<br>熵表示的是数据中包含的信息量大小。熵越小，数据的纯度越高，也就是说数据越趋于一致，这是我们希望的划分之后每个子节点的样子。</p><h3 id="条件熵-conditional-entropy-："><a href="#条件熵-conditional-entropy-：" class="headerlink" title="条件熵(conditional entropy)："></a>条件熵(conditional entropy)：</h3><p>随机变量X给定的条件下，随机变量Y的条件熵H(Y|X)定义为：</p><script type="math/tex; mode=display">H(Y|X)=\sum_{i=1}^np_i*H(Y|X=x_i)</script><p>其中，<script type="math/tex">p_i=P(X=x_i)</script>。</p><h3 id="信息增益-information-gain-："><a href="#信息增益-information-gain-：" class="headerlink" title="信息增益(information gain)："></a>信息增益(information gain)：</h3><p>意义：引入属性A后，原来数据集D的不确定性减少了多少。<br>定义属性A对数据集D的信息增益为$g(D,A)$，它等于D本身的熵减去给定A的条件下D的条件熵，即：  </p><script type="math/tex; mode=display">g(D,A)=H(D)-H(D|A)</script><p>一般地，熵<script type="math/tex">H(Y)</script>与条件熵<script type="math/tex">H(Y|X)</script>之差称为互信息(mutual information)。<br>信息增益越大，则意味着使用属性a来进行划分所获得的 “纯度提升” 越大 。也就是说，用属性a来划分训练集，得到的结果中纯度比较高。</p><h3 id="基尼指数（Gini-index）"><a href="#基尼指数（Gini-index）" class="headerlink" title="基尼指数（Gini index）"></a>基尼指数（Gini index）</h3><p>假设数据集D中有K个类，样本属于第K类的概率为pk，基尼指数Gini(D)表示集合D的不确定性(纯度)，公式如下：</p><script type="math/tex; mode=display">Gini（D）=\sum_{i=1}^Np_k*(1-p_k)=1-\sum_{i=1}^Np_k^2</script><p>从上面的公式可以发现，当数据集D中只有1个类时，pk=1，Gini(D)=0，说明基尼指数越小，样本纯度越高。<br>对于特征A，将集合D划分成D1和D2，基尼指数Gini(D,A)表示经过A=a划分后集合D的不确定性，公式如下：</p><script type="math/tex; mode=display">Gini(D,A)= {|D_1|\over|D|}*Gini(D_1)+{|D_2|\over|D|}*Gini(D_2)</script><p>其中|D|、|D1|、|D2|分别表示数据集D、D1、D2中样本数量。</p><h3 id="误差平方和"><a href="#误差平方和" class="headerlink" title="误差平方和"></a>误差平方和</h3><p>在预测模型时希望真实值和预测值越接近越好，说明预测误差小。若yi表示训练集D={(x1,y1),(x2,y2),…,(xn,yn)}的输出变量，是连续值。f(xi)是预测值，则预测误差可以表示为：</p><script type="math/tex; mode=display">err=\sum[y_i-f(x_i)]^2</script><p>我们拟合的目标就是寻找最佳划分特征里的最佳划分点，找到每一个f(xi)，使得误差平方和最小化。<br>计算各个特征各个值划分的两部分 和D1和D2 的误差平方和，选择误差平方和最小的（如下式）作为最优特征和最优切分点</p><script type="math/tex; mode=display">\min_j,s[min_{c1}\sum_{x_i\epsilon R_1(j,s)}(y_i-c1)^2+min_{c2}\sum_{x_i\epsilon R_2(j,s)}(y_i-c2)^2]</script><p>上面的j是不同的特征，s是对应每个特征可供选择的划分点，因为一个连续特征的值很多，所以划分点很多，要选择最优的。<br>中括号内的意思就是找出针对特征j的最优划分点s，采用均方误差，最外层是特征，计算不同特征。回归的比分类相对麻烦一些，分类只需要计算每个特征的信息增益，回归是计算每个特征的均方误差增益，但是它多了一个步骤就是求每个特征增益的时候还要找出最优划分值s。</p><hr><h2 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h2><p>ID3 使用信息增益作为选择特征的准则，<strong>信息增益 = 划分前熵 - 划分后熵</strong>。信息增益越大，则意味着使用属性a来进行划分所获得的 “纯度提升” 越大 。也就是说，用属性a来划分训练集，得到的结果中纯度比较高</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>从根节点开始，计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的划分特征；</li><li>由该特征的不同取值建立子节点；</li><li>再对子节点递归1-2步，构建决策树；</li><li>直到没有特征可以选择或类别完全相同为止，得到最终的决策树。</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据；缺点：</p><ul><li>只能处理分类属性的数据，不能处理连续的数据；</li><li>没有剪枝，可能会产生过度匹配问题，需要进行剪枝</li><li>采用信息增益作为选择最优划分特征的标准，然而信息增益会偏向那些取值较多的特征</li></ul><hr><h2 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h2><p>C4.5 克服了 ID3 仅仅能够处理离散属性的问题，以及信息增益偏向选择取值较多特征的问题，使用信息增益比来选择特征。<strong>信息增益比 = 信息增益 / 划分前熵</strong>。选择信息增益比最大的作为最优特征。公式：</p><script type="math/tex; mode=display">gR(D,A)={g(D,A)\over H_A(D)}</script><p>其中  <script type="math/tex">H_A(D)=-\sum_{i=1}^n{|D_i|\over|D|}*log2({|D_i|\over|D|})</script>， n 是特征 A 取值的个数<br>C4.5 处理连续特征是先将特征取值排序，以连续两个值中间值作为划分标准。尝试每一种划分，并计算修正后的信息增益，选择信息增益最大的分裂点作为该属性的分裂点。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：<br>（1）通过信息增益率选择分裂属性，克服了ID3算法中通过信息增益倾向于选择拥有多个属性值的属性作为分裂属性的不足；<br>（2）能够处理离散型和连续型的属性类型，即将连续型的属性进行离散化处理；<br>（3）构造决策树之后进行剪枝操作；<br>（4）能够处理具有缺失属性值的训练数据。<br>缺点：<br>（1）算法的计算效率较低，特别是针对含有连续属性值的训练样本时表现的尤为突出。<br>（2）算法在选择分裂属性时没有考虑到条件属性间的相关性，只计算数据集中每一个条件属性与决策属性之间的期望信息，有可能影响到属性选择的正确性。</p><h2 id="CART（分类回归树）"><a href="#CART（分类回归树）" class="headerlink" title="CART（分类回归树）"></a>CART（分类回归树）</h2><h3 id="决策树的思想"><a href="#决策树的思想" class="headerlink" title="决策树的思想"></a>决策树的思想</h3><p>决策树认为，物以类聚、人以群分，在特征空间里相近的样本，那就是一类。如果为每个“类”分配的空间范围比较小，那么，同一个类内的样本差异会非常小，以至于看起来一样。换句话说，如果我们可以将特征空间切分为较小的碎块，然后为每一个碎块内的样本配置一个统一的因变量取值，就有机会做出误差较小的预测。这也是分类和聚类算法的基本假设。<br>它的做法比较粗暴：首先分割特征空间，也就是将样本分组；然后为每一组样本分配一个预测值；最后，在预测阶段，为样本找到分组、找到预测值。<br>这种思想似乎有点道理，值得一试。当然有2个问题需要回答：（1）如何切分特征空间；（2）如何为各个空间碎块设置因变量取值。</p><h3 id="针对离散数据的分类决策树"><a href="#针对离散数据的分类决策树" class="headerlink" title="针对离散数据的分类决策树"></a>针对离散数据的分类决策树</h3><p>假设预测任务的输入和输出都是离散值，我们可以直接以特征的各个取值为候选分割平面（换个说法，就是对训练样本分组），进行决策树的构建——这就是针对离散值的分类决策树。<br>注意，针对离散值的决策树在对训练样本进行分组时，一般情况下不允许重复使用一个特征。而有能力处理连续变量的CART回归树不同，允许重复使用一个特征。</p><h3 id="CART回归树的逻辑结构"><a href="#CART回归树的逻辑结构" class="headerlink" title="CART回归树的逻辑结构"></a>CART回归树的逻辑结构</h3><p>当然，一些情况下，部门不能直接使用特征取值，比如说，特征为连续变量。这时候，我们需要使用一种新的策略，来选择用于分割样本的特征取值。<br>另一种情况下，我们不能使用信息增益、基尼系数这样的指标，作为分组质量的表征——输出值是连续变量。这时候，我们也需要一种新的策略，来评估分组质量。<br>当任务的输出值为连续变量，我们需要使用决策树的另一种版本——回归树。最常见的回归树就是CART回归树。</p><h2 id="实例演示计算"><a href="#实例演示计算" class="headerlink" title="实例演示计算"></a>实例演示计算</h2><div class="table-container"><table><thead><tr><th></th><th>天气</th><th>温度</th><th>湿度</th><th>风速</th><th>活动</th></tr></thead><tbody><tr><td>1</td><td>晴</td><td>炎热</td><td>高</td><td>弱</td><td>取消</td></tr><tr><td>2</td><td>晴</td><td>炎热</td><td>高</td><td>强</td><td>取消</td></tr><tr><td>3</td><td>阴</td><td>炎热</td><td>高</td><td>弱</td><td>进行</td></tr><tr><td>4</td><td>雨</td><td>适中</td><td>高</td><td>弱</td><td>进行</td></tr><tr><td>5</td><td>雨</td><td>寒冷</td><td>正常</td><td>弱</td><td>进行</td></tr><tr><td>6</td><td>雨</td><td>寒冷</td><td>正常</td><td>强</td><td>取消</td></tr><tr><td>7</td><td>阴</td><td>寒冷</td><td>正常</td><td>强</td><td>进行</td></tr><tr><td>8</td><td>晴</td><td>适中</td><td>高</td><td>弱</td><td>取消</td></tr><tr><td>9</td><td>晴</td><td>寒冷</td><td>正常</td><td>弱</td><td>进行</td></tr><tr><td>10</td><td>雨</td><td>适中</td><td>正常</td><td>弱</td><td>进行</td></tr><tr><td>11</td><td>晴</td><td>适中</td><td>正常</td><td>强</td><td>进行</td></tr><tr><td>12</td><td>阴</td><td>适中</td><td>高</td><td>强</td><td>进行</td></tr><tr><td>13</td><td>阴</td><td>炎热</td><td>正常</td><td>弱</td><td>进行</td></tr><tr><td>14</td><td>雨</td><td>适中</td><td>高</td><td>强</td><td>取消</td></tr></tbody></table></div><p>数据集中有四个属性（天气、温度、湿度、风速），类标签有两个（进行和取消）。<br>plus：我们只关注最后的结果是进行还是取消，所以我们在任何分类属性下都只关注类标签的概率，这一点很重要，不然后面都不知道为什么这么计算。</p><h3 id="1-计算类别信息熵"><a href="#1-计算类别信息熵" class="headerlink" title="1. 计算类别信息熵"></a>1. 计算类别信息熵</h3><p>类别信息熵表示的是所有样本中各种类别出现的不确定性之和。根据熵的概念，熵越大，不确定性就越大，把事情搞清楚所需要的信息量就越多。</p><p>按照上文中的公式，我们可以计算在同一属性下的类别信息熵（plus：可能说的不对，但是大概意思是计算在这个属性分类下的类别信息熵，这里突出的是计算同一属性或分类下，其他分类下的类别信息熵则不用管。当没有分类的时候则计算整个数据集下的类别信息熵，计算过程如下）。</p><script type="math/tex; mode=display">H(D)=-9/14*log2(9/14)-5/14*1og2(5/14)=0.940</script><p>其中，9/14是整个数据集下的类标签“进行”的概率，5/14是整个数据集下的类标签“取消”的概率</p><h3 id="2-计算每个属性的信息熵"><a href="#2-计算每个属性的信息熵" class="headerlink" title="2. 计算每个属性的信息熵"></a>2. 计算每个属性的信息熵</h3><p>每个属性的信息熵相当于一种条件熵。他表示的是在某种属性的条件下，各种类别出现的不确定性之和。属性的信息熵越大，表示这个属性中拥有的样本类别越不“纯”。<br>每个属性就相当于按照一定的规则进行了一次分类，在例子中，我们分别对数据集中的四个属性进行初步分类就可以得出每个属性的信息熵。</p><script type="math/tex; mode=display">H(天气)=5/14*[-2/5*log2(2/5)-3/5*log2(3/5)]+4/14*[-4/4*log2(4/4)]+5/14*[-3/5*log2(3/5)-2/5*log2(2/5)]=0.694</script><p>其中，天气的信息熵为晴天的概率（5/14）乘以晴天条件下类别信息熵<script type="math/tex">[-2/5*log2(2/5)-3/5*log2(3/5)]</script>加上阴天的概率（4/14）乘以阴天条件下的类别信息熵<script type="math/tex">[-4/4*log2(4/4)]</script>加上雨天的概率（5/14）乘以雨天条件下的类别信息熵<script type="math/tex">[-3/5*log2(3/5)-2/5*log2(2/5)]</script>。同理：</p><script type="math/tex; mode=display">H(温度)=0.911\\H（湿度）=0.789\\H（风速）=0.892</script><h3 id="3-计算信息增益-ID3"><a href="#3-计算信息增益-ID3" class="headerlink" title="3. 计算信息增益 (ID3)"></a>3. 计算信息增益 (ID3)</h3><p>信息增益的 = 熵 - 条件熵，在这里就是类别信息熵 - 属性信息熵，它表示的是信息不确定性减少的程度。如果一个属性的信息增益越大，就表示用这个属性进行样本划分可以更好的减少划分后样本的不确定性，当然，选择该属性就可以更快更好地完成我们的分类目标。<br>信息增益就是ID3算法的特征选择指标。</p><script type="math/tex; mode=display">g(D,天气)=H（D）-H（天气）=0.246\\g(D,温度)=H（D）-H（温度）=0.029\\g(D,湿度)=H（D）-H（湿度）=0.15\\g(D,风速)=H（D）-H（风速）=0.048</script><p>这里选择最大的信息增益作为根节点，然后再确定这个根节点下再重复过程1~3，确定接下来的各个子跟节点，直到没有特征可以选择或类别完全相同为止，得到最终的决策树。</p><h3 id="4-计算属性分裂信息度量"><a href="#4-计算属性分裂信息度量" class="headerlink" title="4. 计算属性分裂信息度量"></a>4. 计算属性分裂信息度量</h3><p>用分裂信息度量来考虑某种属性进行分裂时分支的数量信息和尺寸信息，我们把这些信息称为属性的内在信息（instrisic information）。信息增益率用<strong>信息增益 / 内在信息</strong>，会导致属性的重要性随着内在信息的增大而减小（也就是说，如果这个属性本身不确定性就很大，那我就越不倾向于选取它），这样算是对单纯用信息增益有所补偿。</p><script type="math/tex; mode=display">H_A（天气）=-5/14*log2（5/14）-4/14*log2（4/14）-5/14*log（5/15）=1.577\\H_A（温度）=1.556\\H_A（湿度）=1.0\\H_A（风速）=0.985</script><h3 id="5-计算信息增益率（C4-5"><a href="#5-计算信息增益率（C4-5" class="headerlink" title="5. 计算信息增益率（C4.5)"></a>5. 计算信息增益率（C4.5)</h3><script type="math/tex; mode=display">gR（天气）=g(D,天气)/H_A（天气）=0.155\\gR（温度）=g(D,温度)/H_A（温度）=0.0186\\gR（湿度）=g(D,湿度)/H_A（湿度）=0.151\\gR（风速）=g(D,风速)/H_A（风速）=0.048\\</script><p>天气的信息增益率最高，选择天气为分裂属性。发现分裂了之后，天气是“阴”的条件下，类别是”纯“的，所以把它定义为叶子节点，选择不“纯”的结点继续分裂。在子结点当中重复过程1~5。</p><h3 id="6-计算基尼指数-（CART分类）"><a href="#6-计算基尼指数-（CART分类）" class="headerlink" title="6. 计算基尼指数 （CART分类）"></a>6. 计算基尼指数 （CART分类）</h3><p>计算各特征的基尼质数，选择最优特征以及最优切分点。<br>以求特征属性天气的基尼质数为例，其中|D|表示整个数据集中样本个数14，$|D_1|$表示天气为晴的样本个数，$|D_2|$表示天气不为晴的样本个数。</p><script type="math/tex; mode=display">Gini(D,天气=晴)={5\over14}*[2*{2\over5}*{3\over5}]+{9\over14}*[2*{7\over9}*{2\over9}]=0.394</script><p>其中${5\over14}$为晴天的概率，$[2<em>{2\over5}</em>{3\over5}] $为晴天条件下的基尼指数，$[2<em>{7\over9}</em>{2\over9}]$为不是晴天条件下的基尼指数。同理：</p><script type="math/tex; mode=display">Gini(D,天气=阴)={4\over14}*[2*{4\over4}*{0\over4}]+{10\over14}*[2*{5\over10}*{5\over10}]=0.357\\Gini(D,天气=雨)={5\over14}*[2*{2\over5}*{3\over5}]+{9\over14}*[2*{6\over9}*{3\over9}]=0.457\\Gini(D,温度=炎热)={4\over14}*[2*{2\over4}*{2\over4}]+{10\over14}*[2*{7\over10}*{3\over10}]=0.443\\Gini(D,温度=适中)={6\over14}*[2*{2\over6}*{4\over6}]+{8\over14}*[2*{5\over8}*{3\over8}]=0.472\\Gini(D,温度=寒冷)={4\over14}*[2*{1\over4}*{3\over4}]+{10\over14}*[2*{6\over10}*{4\over10}]=0.45\\Gini(D,湿度=高)={7\over14}*[2*{4\over7}*{3\over7}]+{7\over14}*[2*{6\over7}*{1\over7}]=0.367\\Gini(D,湿度=正常)={7\over14}*[2*{4\over7}*{3\over7}]+{7\over14}*[2*{6\over7}*{1\over7}]=0.367\\Gini(D,风速=弱)={8\over14}*[2*{6\over8}*{2\over8}]+{6\over14}*[2*{3\over6}*{3\over6}]=0.429\\Gini(D,风速=弱)={8\over14}*[2*{6\over8}*{2\over8}]+{6\over14}*[2*{3\over6}*{3\over6}]=0.429</script><p>由上面计算可知：Gini(D,天气=阴)=0.357最小，则选择阴天为最优特征，是否为阴天为最优切分点，依次计算划分值，重复此过程可生成最后的决策树。</p><h3 id="7-计算残差平方和（CART回归）"><a href="#7-计算残差平方和（CART回归）" class="headerlink" title="7.计算残差平方和（CART回归）"></a>7.计算残差平方和（CART回归）</h3><p>算法流程：</p><ol><li>选择最优切分特征j和切分点s<script type="math/tex; mode=display">\min_j,s[min_{c1}\sum_{x_i\epsilon R_1(j,s)}(y_i-c1)^2+min_{c2}\sum_{x_i\epsilon R_2(j,s)}(y_i-c2)^2]</script></li><li>用选定的对（j，s）划分区域并决定相应的输出值：<script type="math/tex; mode=display">R_1(j,s)={x|x^{(j)}<=s}   R_2(j,s)={x|x^{(j)}>s} c_m={1\over N_m}\sum_{x_i\epsilon R_m(j,s)}y_i\,\,\, x\epsilon R_m,m=1,2</script>第一个式子是将数据按照切分点分成两个节点，第二个是求每个节点的均方误差之和。</li><li>继续对两个子区域调用步骤1，2直至满足停止条件</li><li>将输入空间划分为M个区域， <script type="math/tex">R_1 , R_2 , . . . R_M</script> 生成决策树：<script type="math/tex; mode=display">f(x)=\sum_{i=1}^Mc_mI (x\epsilon R_m)</script>该式子的意思是求分到相同节点的均值作为预测值，后面的指示函数作为划分到那么区域。</li></ol><div class="table-container"><table><thead><tr><th>x</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>y</td><td>5.56</td><td>5.7</td><td>5.91</td><td>6.4</td><td>6.8</td><td>7.05</td><td>8.9</td><td>8.7</td><td>9</td><td>9.05</td></tr></tbody></table></div><p>该式子的意思是求分到相同节点的均值作为预测值，后面的指示函数作为划分到那么区域。<br>特征x包含了10个元素，且已排好序了，直接以(xi+xi+1)/2，i∈{1,2,…,10}为切分点s，容易求得:</p><script type="math/tex; mode=display">R_1{x|x^<=s}\,\,\, R_2={x|x>s}</script><p>则C1、C2为：</p><script type="math/tex; mode=display">c_1={1\over N_1}\sum_{x_i\epsilon R_1}y_i\,\,\,c_2={1\over N_2}\sum_{x_i\epsilon R_2}y_i</script><p>其中N1、N2分别是R1、R2中的样本点数，C1、C2为R1、R2中的因变量均值。<br>针对x考虑如下切分点：1.5、2.5、3.5、4.5、5.5、6.5、7.5、8.5、9.5，可以求出相应的R1、R2、C1、C2，以及 <script type="math/tex">\min_j,s[min_{c1}\sum_{x_i\epsilon R_1(j,s)}(y_i-c1)^2+min_{c2}\sum_{x_i\epsilon R_2(j,s)}(y_i-c2)^2]</script><br>例如，当s=1.5时，R1={1}，R2={2,3,…,10}，C1=5.56，C2=7.5，则</p><script type="math/tex; mode=display">m(s)=\min_j,s[min_{c1}\sum_{x_i\epsilon R_1(j,s)}(y_i-c1)^2+min_{c2}\sum_{x_i\epsilon R_2(j,s)}(y_i-c2)^2]=0+15.72=15.72</script><p>同理可得其它划分点的最小误差如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">s</th><th style="text-align:center">1.5</th><th style="text-align:center">2.5</th><th style="text-align:center">3.5</th><th style="text-align:center">4.5</th><th style="text-align:center">5.5</th><th style="text-align:center">6.5</th><th style="text-align:center">7.5</th><th style="text-align:center">8.5</th><th style="text-align:center">9.5</th></tr></thead><tbody><tr><td style="text-align:center">m(s)</td><td style="text-align:center">15.72</td><td style="text-align:center">12.07</td><td style="text-align:center">8.36</td><td style="text-align:center">5.78</td><td style="text-align:center">3.91</td><td style="text-align:center">1.93</td><td style="text-align:center">8.01</td><td style="text-align:center">11.73</td><td style="text-align:center">15.74</td></tr></tbody></table></div><p>由上表知，当x=6.5时m(s)达到最小值，即此时误差平方和最小。此时R1={1,2,…,6}，R2={7,8,…,10}，C1=6.24、C2=8.9，所以回归树T1(x)为:</p><script type="math/tex; mode=display">f_1(x)=T_1(x)= \begin{cases}6.24.x<6.5\\8.91,x>6.5\end{cases}</script><p>用f1(x)拟合训练数据的残差见下表，表中r2i= yi- f1(xi) (i=1,2,…1,10)。</p><div class="table-container"><table><thead><tr><th>x</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>r2i</td><td>-0.68</td><td>-0.54</td><td>-0.33</td><td>0.16</td><td>0.56</td><td>0.81</td><td>-0.01</td><td>-0.21</td><td>0.09</td><td>0.14</td></tr></tbody></table></div><p>第2步求T2(x)方法与求T1(x)，只是拟合的数据是上表的残差，可以得到</p><script type="math/tex; mode=display">T_2(x)= \begin{cases}-0.52,x<3.5\\0.22,x>=6.5\end{cases}\\f_2(x)=f_1(x)+T_2(x)= \begin{cases}5.72,x<3.5\\6.46,3.5<=x<6.5\\ 9.13,x>=6.5\end{cases}</script><p>可以根据此方法继续求解，直至拟合训练数据的误差平方和小于某个阈值时作为结束条件，那么f(x)=fi(x)即为所求回归树。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习，决策树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python复习日记</title>
      <link href="/2022/07/23/python%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>/2022/07/23/python%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="算法学习日记python篇-—day-1-2022-7-23"><a href="#算法学习日记python篇-—day-1-2022-7-23" class="headerlink" title="算法学习日记python篇   —day 1 2022-7-23"></a>算法学习日记python篇   —day 1 2022-7-23</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="声明：这是一个复习blog，记录复习过程中的各种题库。资料由于是在网上收集的，所以可能出现各种大范围雷同。如果侵犯您的版权，请评论留言，我会第一时间做出相应调整。在此，特别鸣谢：Java架构师必看的进大厂必须掌握的面试题-100个python面试"><a href="#声明：这是一个复习blog，记录复习过程中的各种题库。资料由于是在网上收集的，所以可能出现各种大范围雷同。如果侵犯您的版权，请评论留言，我会第一时间做出相应调整。在此，特别鸣谢：Java架构师必看的进大厂必须掌握的面试题-100个python面试" class="headerlink" title="声明：这是一个复习blog，记录复习过程中的各种题库。资料由于是在网上收集的，所以可能出现各种大范围雷同。如果侵犯您的版权，请评论留言，我会第一时间做出相应调整。在此，特别鸣谢：Java架构师必看的进大厂必须掌握的面试题-100个python面试"></a>声明：这是一个复习blog，记录复习过程中的各种题库。资料由于是在网上收集的，所以可能出现各种大范围雷同。如果侵犯您的版权，请评论留言，我会第一时间做出相应调整。在此，特别鸣谢：Java架构师必看的<a href="https://zhuanlan.zhihu.com/p/270331009">进大厂必须掌握的面试题-100个python面试</a></h3><ul><li><a href="#基本面试问题">基本面试问题</a></li><li><a href="#OOPS面试问题">OOPS面试问题</a></li><li><a href="#基本的python程序">基本的python程序</a></li><li><a href="#python库">python库</a></li></ul><h2 id="基本面试问题"><a href="#基本面试问题" class="headerlink" title="基本面试问题"></a>基本面试问题</h2><ol><li><p>python中的列表和元组有什么区别？、</p><ul><li><p>列表中的元素可以修改，元组中的元素不可修改，除非整个元组替换掉！</p></li><li><p>元组比列表更加轻量级，性能速度优于列表</p></li><li><p>元组可以在映射中当“键”使用，列表不能</p></li></ul></li><li><p>python主要功能是什么？</p><ul><li>python是一种解释型语言，与c语言不同，不需要编译</li><li>python是动态类型的，不需要声明变量的类型</li><li>python适合面向对象编程，因为它允许定义类以及组成和继承。python没有访问说明（如C++的public，private）（访问说明就是设置一个访问权限，不同人有着不同的权限）</li><li>编写代码速度快，但运行时比编译语言要慢，但python允许C的扩展，可以很大部分消除瓶颈</li><li>python有很多库，可以快速实现某项功能和解决某个问题</li></ul></li><li><p>python是一种什么类型的语言？编程还是脚本？</p><p>python能够编写脚本，但一般认为他是通用编程语言</p></li><li><p>python是一种解释语言吗？</p><p>python是一种解释型语言。（解释型语言是指运行之前不需要编译，在运行时执行一句翻译一句为机器语言）</p></li><li><p>什么是pep 8？</p><p>PEP代表python增强建议书（PEP8：python编程规范）。这是一组规则，用于指定如何格式化python代码以实现最大的可读性。</p></li><li><p>如何在python中管理内存？</p><p>Python引用了一个内存池(memory pool)机制，即Pymalloc机制(malloc:n.分配内存)，用于管理对小块内存的申请和释放。</p><p>主要有三种机制：</p><ul><li>引用计数机制。python内部使用引用计数，来保持追踪内存中的对象，python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。</li><li>垃圾回收机制。当内存中有不再使用的部分时（引用数为0），垃圾收集器就会把他们清理掉。它会去检查那些引用计数为0的对象，然后清除其在内存的空间；循环垃圾回收器（a引用b，b引用a，这种相互引用也会被清除）。</li><li>内存池机制。内存池的概念就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。python引入内存池机制用于管理小块内存的申请和释放；同时，python将释放的内存返回给内存池，而不是操作系统；对于python对象（整数，浮点数和list等）有着独有的私有内存池，不同对象的内存池不共享。</li></ul></li><li><p>python的命名空间是什么？</p><p>命名空间是用于确保名称唯一以确保命名冲突的命名系统</p></li><li><p>什么是pythonpath？<br>这是一个环境变量，在导入模块时使用。当导入模块的时候，都会查找pythonpath以检查各个目录中是否存在导入的模块，解释器使用它来确定要加载哪个模块。</p></li><li><p>什么是python模块？命名python中一些常用的内置模块？<br>python模块是包含python代码的文件。该代码可以是函数类或者变量。python模块是包含可执行代码的.py文件<br>一些常用的内置模块是：</p><ul><li>操作系统-OS</li><li>系统-sys</li><li>数学-math</li><li>随机-random</li><li>资料时间-data time</li><li>JSON格式</li></ul></li><li><p>python中的局部变量和全局变量是什么？<br>全局变量：在函数外部或全局空间声明的变量，可被程序中的任何函数访问<br>局部变量：在函数内部声明的变量，只能在函数局部空间内被访问</p></li><li><p>python是否区分大小写？<br>是的，区分。</p></li><li><p>什么是python中的类型转换？<br>类型转换是将一种数据转换为另一种数据类型。</p><ul><li>int（） 转换为整数类型</li><li>float（） 转换为浮点数</li><li>ord（） 将字符转换为整数</li><li>hex（） 整数转换为十六进制</li><li>oct（） 整数转换为八进制</li><li>tuple（） 转换为元组</li><li>set（） 转换为集合后返回类型</li><li>list（） 转换为列表</li><li>dict（）此函数用于将顺序（键，值）的元组转换为字典</li><li>str（） 转换为字符串</li></ul></li><li><p>如何在windows上安装python并设置路径变量？<br>从<a href="www.python.org">官网</a>上下载安装包，并按照提示符安装。<br>将安装路径添加到环境变量中（如点击计算机-&gt;属性-&gt;高级-&gt;环境变量-&gt;修改系统变量 path）</p></li><li><p>python是否需要缩进？<br>需要的，一般使用tab键缩进（四个空格）</p></li><li><p>python数组和列表有什么区别？<br>数组中的数据类型必须相同，列表则可以有多个数据类型元素。</p></li><li><p>python中的函数是什么？<br>是通过def语句定义的代码块，包含函数名，参数列表和函数体。</p></li><li><p>什么是init？<br>init是Python中的方法或构造函数。创建类的新对象/实例时，将自动调用此方法以分配内存。所有类都具有init方法。</p></li><li><p>什么是lambda函数？<br>匿名函数被称为lambda函数，此函数可以有任何数量的参数，但只能有一个语句</p></li><li><p>python中的self是什么？<br>self是类的实例或对象。在python中，这包括为第一个参数。init方法中的self变量引用新创建的对象，而其他方法中的self变量引用其方法被调用的对象。</p></li><li><p>什么是break、continue和pass？</p><ul><li>break：跳出当前循环</li><li>continue： 跳出本次循环，后面语句不再执行</li><li>pass：主要用于占位</li></ul></li><li><p>[::-1]是做什么的？<br>用于逆序输出，原始数组或者列表保持不变。</p></li><li><p>如何在python中将列表项随机化？<br>利用random库中的相关函数实现相关功能。</p></li><li><p>什么是python迭代器？<br>迭代器是可以遍历或迭代的对象。</p></li><li><p>如何在python中生成随机数？<br>调用random库中的相关函数。如：</p><p>random.random()  返回[0,1)范围内的随机浮点数。</p></li><li><p>range()和xrange()有什么区别吗？<br>功能基本一致，但xrange（）对内存使用更加友好一点</p></li><li><p>如何在python中写注释？<br>使用#注释，有时候也可以用三引号引起来的字符串进行注释。</p></li><li><p>什么是**pickling和unpickling**？<br>pickle模块接受任何python对象并将其转换为字符串表示形式，并使用转储函数将其转储到文件中，此过程称之为pickling，从存储的字符串表示形式检索原始python对象的过程称为unpickling。</p></li><li><p>python中的生成器什么？<br>返回可迭代项目集的函数称为生成器。</p></li><li><p>如何大写字符串的第一个字母？<br>capitalize（）函数将字符串的首字母大写。</p></li><li><p>如何将字符串全部小写？<br>lower（）函数</p></li><li><p>如何在python中注释多行？<br>每行都要以#开头，不过jupyter 或pycharm有快捷键ctrl+/</p></li><li><p>python中的文档字符串是什么？<br>文档字符串用三引号引起来，没有被分配任何变量，有注释作用。</p></li><li><p>操作符和操作符的目的是什么？<br>可分为运算符和分隔符。运算符是特殊功能。它们采用一个或多个值并产生相应的结果。</p></li><li><p>python中的help（）和dir（）函数的用法是什么？<br>Help（）和dir（）这两个函数都可以从Python解释器访问，并用于查看内置函数的合并转储。Help（）函数：help（）函数用于显示文档字符串，还可以帮助您查看与模块，关键字，属性等有关的帮助；Dir（）函数：dir（）函数用于显示定义的符号。</p></li><li><p>当python退出时，为什么不取消分配所有内存？<br>那些具有对象循环引用或者全局命名空间引用的变量，在 Python 退出是往往不会被释放的，另外不会释放 C 库保留的部分内容。</p></li><li><p>python中的字典是什么？<br>python中的内置数据类型称为字典，它定义了键和值之间的一对一关系。字典包含一对键及其对应的值。字典由键索引。</p></li><li><p>如何在python中使用三元运算符？（这个我目前还不懂是啥）<br>三元运算符是用于显示条件语句的运算符。它由true或false值以及必须对其评估的语句组成。</p></li><li><p>*args,*kwargs是什么？有什么作用？<br>当我们不确定向函数传递多少参数时，或者将存储的参数列表或元组传递给函数时，可以使用*arges,* kwargs在我们不知道将多少个关键字参数传递给一个函数时使用，或者可用于将字典的值作为关键字参数传递</p></li><li><p>len()是做什么的？<br>确定字符串、列表、数组的长度</p></li><li><p>解释python中”re”模块的split（），sub（）、subn（）方法<br>为了修改字符串，Python的“ re”模块提供了3种方法：</p><ul><li>split（）–使用正则表达式模式将给定的字符串“拆分”为列表</li><li>sub（）–查找所有与正则表达式模式匹配的子字符串，然后将其替换为其他字符串</li><li>subn（）–它类似于sub（），并且还返回新字符串以及no更换</li></ul></li><li><p>什么是负索引，为什么要使用他们？<br>当遍历所索引序列时，可以从序列由前到后遍历，此时索引数为正，也是就正索引，同理当有后向前遍历序列时，索引数为负数，就是负索引，何时使用正索引还是负索引完全看具体情况哪种索引方便，一个从前往后数，一个从后往前数，方向不一致而已。</p></li><li><p>什么是python包？<br>python软件包是包含多个模块的名称空间</p></li><li><p>如何用python删除文件？<br>导入OS模块，使用<code>os.remove</code>即可</p></li><li><p>python的内置类型是什么？<br>python的内置类型如下：</p><ul><li>Integers</li><li>Floating-point</li><li>Complex numbers</li><li>Strings</li><li>Boolean</li><li>Built-in functions</li></ul></li><li><p>与python列表相比，numpy数组有什么优势？<br>相比来说，numpy不仅效率更高，而且更加方便。可以支持“向量化”操作，可以快速简单地实现矩阵和矢量运算；而且速度还更快，功能更加丰富。</p></li><li><p>如何将值添加到python数组组？<br>可以使用相关函数将元素添加到数组里面。如：append（），extend（），insert（i，x）。</p></li><li><p>如何删除值到python数组？<br>可以使用相关函数实现该功能。pop（）：返回删除值；remove（）：不返回删除值。</p></li><li><p>python是否具有OOps概念？<br>Python是一种面向对象的编程语言。这意味着可以通过创建对象模型在python中解决任何程序。但是，Python既可以当作过程语言，也可以当作结构语言。</p></li><li><p>深层复制和浅层复制有什么区别？<br>浅层复制：实现对象间数据元素的一一对应复制；深层复制：当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针所指对象进行复制。在python中，浅层复制会随原对象变化而变化，深层复制则不会。</p></li><li><p>如何在python中实现多线程？<br>可以通过导入threading模块来实现。（但我没试过，不知道效果咋样）</p></li><li><p>在python中编译和链接的过程是什么？<br>编译：python中的源代码保存为.py文件，然后将其编译为称为字节码的格式，然后将字节码转换为机器码。编译后，代码存储在.pyc文件中，并在更新源代码时重新生成。此过程称为编译；<br>链接：链接是最后一个阶段，其中所有功能都与它们的定义链接在一起，因为链接器知道在哪里实现所有这些功能。此过程称为链接。<br>在python中编译和链接允许正确编译新扩展而不会出现任何错误，并且只有在通过编译过程时才能进行链接。如果使用动态加载，则它取决于系统提供的样式。</p></li><li><p>什么是python库？<br>python库是python软件包的集合。如numpy，pandas，matplotlib，scikit-learn等。</p></li><li><p>拆分的用途是什么？<br>split（）用于分割给定的字符串。</p></li><li><p>在python中如何导入模块？<br>使用关键字import导入，有三种方式导入：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> array <span class="keyword">as</span> arr</span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></li><li><p>dict 的 items() 方法与 iteritems() 方法的不同？</p><p>items方法将所有的字典以列表方式返回，其中项在返回时没有特殊的顺序；</p><p>iteritems方法有相似的作用，但是返回一个迭代器对象</p></li><li><p>说明OS，sys模块的不同，并列举常用的模块方法</p><p>os：提供了一种方便的使用操作系统的方法</p><p>sys：可供访问由解释器使用或维护的变量和与解释器进行交互的函数</p><p>总结：os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。</p><p>os常用方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.remove(‘path/filename’) #删除文件</span><br><span class="line">os.rename(oldname, newname) #重命名文件</span><br><span class="line">os.walk() #生成目录树下的所有文件名</span><br><span class="line">os.chdir(&#x27;dirname&#x27;) #改变目录</span><br><span class="line">os.mkdir/makedirs(&#x27;dirname&#x27;) #创建目录/多层目录</span><br><span class="line">os.rmdir/removedirs(&#x27;dirname&#x27;) #删除目录/多层目录</span><br><span class="line">os.listdir(&#x27;dirname&#x27;) #列出指定目录的文件</span><br><span class="line">os.getcwd() #取得当前工作目录</span><br><span class="line">os.chmod() #改变目录权限</span><br><span class="line">os.path.basename(‘path/filename’) #去掉目录路径，返回文件名</span><br><span class="line">os.path.dirname(‘path/filename’) #去掉文件名，返回目录路径</span><br><span class="line">os.path.join(path1[,path2[,...]]) #将分离的各部分组合成一个路径名</span><br><span class="line">os.path.split(&#x27;path&#x27;) #返回( dirname(), basename())元组</span><br><span class="line">os.path.splitext() #返回 (filename, extension) 元组</span><br><span class="line">os.path.getatime\ctime\mtime #分别返回最近访问、创建、修改时间</span><br><span class="line">os.path.getsize() #返回文件大小</span><br><span class="line">os.path.exists() #是否存在</span><br><span class="line">os.path.isabs() #是否为绝对路径</span><br><span class="line">os.path.isdir() #是否为目录</span><br><span class="line">os.path.isfile() #是否为文件</span><br></pre></td></tr></table></figure><p>sys常用方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys.argv #命令行参数List，第一个元素是程序本身路径</span><br><span class="line">sys.modules.keys() #返回所有已经导入的模块列表</span><br><span class="line">sys.exc_info() #获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息</span><br><span class="line">sys.exit(n) #退出程序，正常退出时exit(0)</span><br><span class="line">sys.hexversion #获取Python解释程序的版本值，16进制格式如：0x020403F0</span><br><span class="line">sys.version #获取Python解释程序的版本信息</span><br><span class="line">sys.maxint #最大的Int值</span><br><span class="line">sys.maxunicode #最大的Unicode值</span><br><span class="line">sys.modules #返回系统导入的模块字段，key是模块名，value是模块</span><br><span class="line">sys.path #返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line">sys.platform #返回操作系统平台名称</span><br><span class="line">sys.stdout #标准输出</span><br><span class="line">sys.stdin #标准输入</span><br><span class="line">sys.stderr #错误输出</span><br><span class="line">sys.exc_clear() #用来清除当前线程所出现的当前的或最近的错误信息</span><br><span class="line">sys.exec_prefix #返回平台独立的python文件安装的位置</span><br><span class="line">sys.byteorder #本地字节规则的指示器，big-endian平台的值是&#x27;big&#x27;,little-endian平台的值是&#x27;little&#x27;</span><br><span class="line">sys.copyright #记录python版权相关的东西</span><br><span class="line">sys.api_version #解释器的C的API版本</span><br><span class="line">sys.stdin,sys.stdout,sys.stderr</span><br></pre></td></tr></table></figure></li><li><p>Python里面如何拷贝一个对象？deepcopy 和 copy的区别？</p><p>copy: 仅拷贝对象本身，而不拷贝对象中引用的其它对象;</p><p>deepcopy: 除拷贝对象本身，而且拷贝对象中引用的其它对象。</p></li><li><p>os.path和sys.path的区别？</p><p>os.path是module，包含了各种处理长文件名(路径名)的函数；</p><p>sys.path是由目录名构成的列表，Python 从中查找扩展模块( Python 源模块, 编译模块,或者二进制扩展)。 启动 Python 时,这个列表从根据内建规则,PYTHONPATH 环境变量的内容, 以及注册表( Windows 系统)等进行初始化。</p></li><li><p>re模块中match和search方法的不同？</p><p>match() 函数只检查 RE 是否在字符串开始处匹配，而search() 则是扫描整个字符串。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">print(re.match(&#x27;super&#x27;, &#x27;superstition&#x27;).span()) #检查super在字符串superstition中是否匹配，因为superstition中的super字符串在开头，此时，返回super在superstition中的起止位置；.span（）返回一个包括匹配的起止位置元组</span><br><span class="line">(0,5)</span><br><span class="line">print(re.match(&#x27;super&#x27;,&#x27;insuperable&#x27;)) #因为super不在insuperable的开头，所以返回none</span><br><span class="line">None</span><br><span class="line">print(re.search(&#x27;super&#x27;,&#x27;superstition&#x27;).span())</span><br><span class="line">(0,5)</span><br><span class="line">print(re.search(&#x27;super&#x27;,&#x27;insuperable&#x27;).span())</span><br><span class="line">(2,7)</span><br></pre></td></tr></table></figure></li><li><p>解释生成器(generator)与函数的不同，并实现和使用简单generator？</p><p>生成器和函数的主要区别在于函数 return a value，生成器 yield a value同时标记或记忆point of the yield 以便于在下次调用时从标记点恢复执行。 yield 使函数转换成生成器，而生成器反过来又返回迭代器。生成器的优点在于处理比较大的列表时节约内存。</p><p>利用函数生成Fibonacci系列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun(max): n为数量</span><br><span class="line">    a=[]</span><br><span class="line">    a.append(0)</span><br><span class="line">    a.append(1)</span><br><span class="line">    for i in range(max-2):</span><br><span class="line">        a.append(a[-1]+a[-2])</span><br><span class="line">    return a</span><br><span class="line">#主函数</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">for m in fun(10):</span><br><span class="line">    print(m,end=&quot; &quot;)</span><br></pre></td></tr></table></figure><p>利用生成器生成Fibonacci系列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun(max):</span><br><span class="line">n1=0 #第一个值</span><br><span class="line">n2=1 #第二个值</span><br><span class="line">num=0 #记录数量</span><br><span class="line">while num&lt;max:</span><br><span class="line">yield n1</span><br><span class="line">n1,n2=n2,n1+n2</span><br><span class="line">num+=1</span><br><span class="line">#主函数</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">for n in fun(10):</span><br><span class="line">print(n,end=&quot; &quot;)</span><br></pre></td></tr></table></figure></li><li><p>解释一下 WSGI 和 FastCGI 的关系？</p><p>CGI全称是“公共网关接口”(CommonGateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。</p><p>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute模式)。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</p><p>FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。</p><p>WSGI的全称为： PythonWeb Server Gateway Interface v1.0 （Python Web 服务器网关接口），</p><p>它是 Python 应用程序和 WEB 服务器之间的一种接口。</p><p>它的作用，类似于FCGI 或 FASTCGI 之类的协议的作用。</p><p>WSGI 的目标，是要建立一个简单的普遍适用的服务器与 WEB 框架之间的接口。</p><p>Flup就是使用 Python 语言对 WSGI 的一种实现，是可以用于 Python 的应用开发中的一种工具或者说是一种库。</p><p>Spawn-fcgi是一个小程序，这个程序的作用是管理fast-cgi进程，那么管理wsgi进程也是没有问题的，功能和php-fpm类似。</p><p>故，简单地说，WSGI和FastCGI都是一种CGI，用于连接WEB服务器与应用程序，而WSGI专指Python应用程序。而flup是WSGI的一种实现，Spawn-fcgi是用于管理flup进程的一个工具，可以启动多个wsgi进程，并管理它们。</p></li><li><p>解释一下 Django 和 Tornado 的关系、差别（待解决）</p></li></ol><h2 id="OOPS面试问题"><a href="#OOPS面试问题" class="headerlink" title="OOPS面试问题"></a>OOPS面试问题</h2><ol><li><p>用一个例子解释python中的继承。</p><p> 继承允许一个类获取另一个类的所有成员（如属性和方法）。继承提供了代码可重用性，使创建和维护应用程序变得更加容易。我们继承的类称为超类，而继承的类称为派生/子类。</p><p> python支持的不同类型继承：</p><ol><li>单一继承：派生类获取某个超类的成员</li><li>多级继承：从基类base1继承的派生类的d1和从base2继承的d2</li><li>层级继承：从一个基类可以继承任意数量的子类</li><li>多重继承：派生类继承自多个基类</li></ol></li><li><p>如何在python中创建类？</p><p> 使用关键字class创建</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ssp</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,sex</span>):<span class="comment">#self代表类的实例，是通过类创建的实例</span></span><br><span class="line">self.name=name</span><br><span class="line">self.age=age</span><br><span class="line">self.sex=sex</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;姓名:&#123;0&#125;;年龄:&#123;1&#125;;性别:&#123;2&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;sex&quot;</span>))</span><br><span class="line">ssp=ssp(<span class="string">&quot;ssp&quot;</span>,<span class="string">&quot;24&quot;</span>,<span class="string">&quot;man&quot;</span>)</span><br><span class="line">ssp.name</span><br><span class="line"><span class="string">&#x27;ssp&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>python中的猴子补丁是什么？</p><p>  在Python中，术语“猴子补丁”仅指运行时对类或模块的动态修改。</p></li><li><p>python是否支持多重继承？</p><p> 多重继承意味着一个类可以从多个父类派生，python支持多重继承。</p></li><li><p>什么是python中的多态？</p><p> 多态性是指采取多种形式的能力。例如，如果父类具有一个名为ABC的方法，则子类也可以具有一个具有相同名称和参数的ABC方法。Python允许多态。</p></li><li><p>在python中定义封装？</p><p> 封装意味着将代码和数据绑定在一起。</p></li><li><p>如何在python中进行数据抽象？</p><p> 在python中可以使用接口和抽象类来实现。</p></li><li><p>python是否使用访问说明符？</p><p> 否！python不会剥夺对实例变量或函数的访问权限。python提出了在变量，函数或方法的名称前加上单下划线或双下划线的概念，类似于保护和私有访问说明符。</p></li><li><p>如何在python中创建一个空类？</p><p> 空类是在其块内未定义任何代码的类，可以使用空语句pass来创建。</p></li><li><p>object（）有什么作用？</p><p>返回一个无特征的对象，该对象是所有类的基础，而且，它不带任何参数。</p></li></ol><h2 id="基本的python程序"><a href="#基本的python程序" class="headerlink" title="基本的python程序"></a>基本的python程序</h2><ol><li><p>用python编写程序执行冒泡排序算法。</p><p> 冒泡算法：一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maopao</span>(<span class="params">a</span>):</span><br><span class="line"><span class="built_in">len</span>=<span class="built_in">len</span>(a)<span class="comment">#获取列表的长度</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[i]&gt;a[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment">#c=a[i]</span></span><br><span class="line">                <span class="comment">#a[i]=a[i+1]</span></span><br><span class="line">                <span class="comment">#a[i+1]=c</span></span><br><span class="line">                a[i],a[i+<span class="number">1</span>]=a[i+<span class="number">1</span>],a[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></li><li><p>用python编写程序生成星型三角形。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def sjx(a):#a为三角形层数</span><br><span class="line">for i in range(a):</span><br><span class="line">print(&#x27; &#x27;*(a+1-i)+&#x27;*&#x27;*(2*i+1))</span><br><span class="line">sjx(9)</span><br></pre></td></tr></table></figure></li><li><p>编写程序用python生成Fibonacci系列。</p><p> Fibonacci系列：由0和1开始，之后的费波那契系数就由之前的两数相加。首几个费波那契系数是：0，1，1，2，3，5，8，13，21……</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=[]</span><br><span class="line">b=int(input())#生成多少个</span><br><span class="line">a.append(0)</span><br><span class="line">a.append(1)</span><br><span class="line">for i in range(b-2):</span><br><span class="line">a.append(a[-1]+a[-2])</span><br><span class="line">print(a) </span><br></pre></td></tr></table></figure><ol><li><p>用python编写程序检查数字是否为质数。</p><p> 质数：一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。质数p的约数只有两个：1和p。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a= int(input()) </span><br><span class="line">b=0</span><br><span class="line">for i in range(2,a-1):</span><br><span class="line">if a/i==int(a/i):</span><br><span class="line">b+=1</span><br><span class="line">else:</span><br><span class="line">b+=0</span><br><span class="line">if b==0:</span><br><span class="line">print(yes)</span><br><span class="line">else:</span><br><span class="line">print(no)</span><br></pre></td></tr></table></figure></li><li><p>用python编写程序以检查序列是否是回文。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=input()</span><br><span class="line">b=a[::-1]</span><br><span class="line">if a==b:</span><br><span class="line">print(yes)</span><br><span class="line">else:</span><br><span class="line">print(no)</span><br></pre></td></tr></table></figure></li><li><p>编写一个单行，将计算文件中大写字母的数量。即使文件太大而无法容纳在内存中，您的代码也应该可以工作。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f=open(&quot;lujing&quot;,&#x27;r&#x27;)</span><br><span class="line">a=f.readlines()</span><br><span class="line">count=0</span><br><span class="line">for i in a:</span><br><span class="line">for j in i:</span><br><span class="line">if j.isupper():</span><br><span class="line">count+=1</span><br><span class="line">##转换为单行</span><br><span class="line">count sum(1 for i in a for j in i if j.isupper())</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>用python为数字数据集编写排序算法</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=input()</span><br><span class="line">c=a</span><br><span class="line">b=[]</span><br><span class="line">for in in range(len(a)-1):</span><br><span class="line">b.append(c.min())</span><br><span class="line">c.remove(c.min())</span><br><span class="line">b.append(a.max())</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网搭建方法</title>
      <link href="/2022/07/18/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/18/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>声明：为了自主维护国内网络环境安全，请大家在享受上网的快乐时能够恪守好自己的底线，不要干违法犯罪的事情。谨记一条：要想人不知，除非己莫为！！！不要到了最后才追悔莫及。我们坚信：网络永远都不是法外之地。</strong></p><h2 id="为什么要“科学上网”？"><a href="#为什么要“科学上网”？" class="headerlink" title="为什么要“科学上网”？"></a>为什么要“科学上网”？</h2><h3 id="有感而发"><a href="#有感而发" class="headerlink" title="有感而发"></a>有感而发</h3><p>众所周知，国内外网络之间有一堵“墙”的存在，那也是我们很多时候不能直接访问国外网站的根本原因。首先，对于普通人来说，这堵“墙”的存在根本不影响我们正常的上网需求。在此，我必须声明一点：国外的月亮并没有我们想象的那么圆！！！国外的网络上并没有特别稀奇古怪的东西，反而偏见到显得很严重（就我自己所看到的而言，外面充斥着各种反华言论，而且里面的论据绝大部分都是他们捏造和凭空想象的，因此去看完全是玷污自己的眼球和三观，纯属自己给自己找恶心！！！虽然国内有着很多待发展和完善的地方，但我们要站在自己国家的立场上想想，外面的世界是残酷的，人与人是这样，国与国也更是这样。作为我们普通人来说，我们还可以找一个真心朋友说说真心话，但国与国之间只有利益。而在利益面前，只有强大才是永恒的真理。所以国家为了更好地保护好我们，只有让自己不断变得更加强大。而在变强的过程中，她是孤独的，也肯定会犯一些错误。然而，作为她的儿女，我们必须得对自己国家多一点宽容和时间，通过正规渠道及时帮她纠正错误，共同缔造属于中华民族的神话!!!</p><h3 id="翻过去有什么用？"><a href="#翻过去有什么用？" class="headerlink" title="翻过去有什么用？"></a>翻过去有什么用？</h3><p>首先，如果能够实现“科学上网”，你能浏览国外大部分网站（国内网站已经做的很好了，基本需求都可以被满足，国外也没有比国内好多少，外国的月亮并不比国内的圆）。本人由于学习需要，需要经常上<a href="%5BGitHub%5D(https://github.com/)">Github</a>上面去学习（搬运）代码，为了学习过程更加流畅和稳定，就产生了翻“墙”的需求。市面上虽然会有很多“梯子”售卖，但大多不稳定和不安全，因此，本人开始学习自己搭建梯子。本文是一个分享贴，也是自我学习的记录贴（其中记载了自己趟过的不少坑）。话不多说，咱们直接开始。</p><h1 id="如果搭建属于自己的“梯子”？"><a href="#如果搭建属于自己的“梯子”？" class="headerlink" title="如果搭建属于自己的“梯子”？"></a>如果搭建属于自己的“梯子”？</h1><p>首先，搭建属于自己的“梯子”需要下列几步：</p><ol><li><a href="#%E8%B4%AD%E4%B9%B0VPS%EF%BC%88%E5%9B%BD%E5%A4%96%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89">购买VPS（国外服务器）</a></li><li><a href="#%E8%B4%AD%E4%B9%B0%E5%9F%9F%E5%90%8D">购买域名</a></li><li><a href="#%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%EF%BC%89">部署环境（服务器端）</a></li><li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE">使用“梯子”（客户端）</a></li></ol><h2 id="购买VPS（国外服务器）"><a href="#购买VPS（国外服务器）" class="headerlink" title="购买VPS（国外服务器）"></a>购买VPS（国外服务器）</h2><p>我们需要购买一台服务器搭载我们的“梯子“项目。为了更加方便地完成项目，我们建议直接购买”墙“外的服务器（推荐香港）。然而现在服务器商也有很多，因此同等配置下，不同服务器商的价格也大不相同。怎么去选适合自己的就因人而异，不过我们建议新手还是选择国内大品牌的(理由很简单，实在折腾不成功可以申请退款，退款快也方便，这一点就很帅)。配置的话，我建议新手选个低配先玩玩就行，后面看需求升级配置，系统我选的（CentOS）。</p><p>购买完服务器后在服务器商的控制台上找到所购买的服务器，需要使用远程登陆软件（我使用的putty，进入<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">putty官网</a>下载安装即可）（备注，建议先在控制台重置密码，重置密码后直接使用putty连接服务器即可</p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>为了更好地伪装我们的”梯子“，我们需要购买一个国内的域名（国外的价格贵，流程麻烦，转回国内还需要一大笔钱，别问我是怎么知道的，我只知道我的钱包又空了一大截），建议直接在同一服器商下购买，他会赠送一些服务，后面会省不少事。追求性价比的选个便宜的就行，一般10块左右就可以买一年了，相当便宜了。</p><p>购买完域名进入直接在控制台搜索DNS解析，然后进入选择添加域名，输入你所购买的域名，然后确定。然后选中你的域名，点击解析，不同服务器商弹出来的页面可能不一致，不过通常都是使用DNSPod解析或云解析，随便选一个就行点进去，然后选择快速添加解析，选择网站解析，网站地址中选择轻量应用服务器，输入你的服务器ip就行。最好接下来点一下ssl跟着提示正常提示申请一下ssl证书，选择免费证书就行。</p><h2 id="部署环境（服务器端）"><a href="#部署环境（服务器端）" class="headerlink" title="部署环境（服务器端）"></a>部署环境（服务器端）</h2><p>使用putty连接上服务器，具体怎么连接百度一下就行，过程贼简单，这就不多赘述。连上服务器后，我们可以跟着V2ray官网<a href="https://www.v2ray.com/">Project V · Project V 官方网站 (v2ray.com)</a>（不过被”墙了，需要通过“科学上网”的方式才能查看），不过接下来我会介绍主要的流程。</p><h3 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h3><p>这个很重要，建议一开始就进行，将服务器时间设为北京时间。具体做法为，在putty中输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date 查看当前服务器时间</span><br><span class="line">yum -y install nptdate  安装nptdate</span><br><span class="line">ntpdate -u 210.72.145.44  同步时间，210.72.145.44：中国国家授时中心的官方服务器</span><br><span class="line">date  查看修改后的时间是否为你电脑一致</span><br></pre></td></tr></table></figure><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>安装相关依赖软件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum makecache</span><br><span class="line">yum install curl</span><br></pre></td></tr></table></figure><p>下载主程序安装脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh</span><br></pre></td></tr></table></figure><p>执行安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash install-release.sh</span><br></pre></td></tr></table></figure><p>等待安装结束，期间可能会有各种错误出来。本人建议把错误直接复制到百度即可解决绝大部分错误，本人亲测方便有效。解决完错误再重新安装就行，这个过程有可能是短暂的，有可能是煎熬的。安装成功后会出现以下界面，到这，恭喜你，成功一大半了。</p><p><img src="/./%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/1.png"></p><p>运行v2ray</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start v2ray</span><br><span class="line">systemctl enable v2ray 设置开机自启动</span><br></pre></td></tr></table></figure><p>查看v2ray是否运行成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status v2ray</span><br></pre></td></tr></table></figure><p>出现以下界面即可运行成功，特别注意显示Active :active(running)才是正常运行状态</p><p><img src="/./%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/2.png"></p><h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><p>输入命令行<code>v2ray</code>即可出现下列界面，然后输入对应的数字即可完成对应的命令!</p><p><img src="/./%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/3.png"></p><p>我们选择修改 V2Ray 配置中的修改 V2Ray 传输协议，然后选择其中一种协议即可（并不是所有的协议都可用，这里建议多试几个），具体操作就是输入2–&gt;2–&gt;输入你选择的协议数字</p><p>选择好协议后输入<code>v2ray  URL</code>,即可生成url，把它复制下来，后面有用</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>进入v2ray官网<a href="https://www.v2ray.com/awesome/tools.html">神一样的工具们 · Project V 官方网站 (v2ray.com)</a>下载V2RayN，或者直接百度下载V2RayN应该也可以。下载后解压到一个文件夹，找到文件夹内的v2rayn.exe文件，双击打开，在左上角服务器栏选择从剪切板导入批量URL，导入后你就能查看你的服务器了，然后在主界面选中你的服务器，右键选择测试服务器速度，如果后面显示出有网速，那么恭喜你，大功告成了！右键v2ray小图标，选择服务器，选择自动配置系统代理就可以“科学上网”了。（每次退出的时候记得清除系统代理）</p><p>（plus：手机端也可以使用，下载v2rayNG安装到手机，然后也是导入URL就行）</p><p>避坑建议：</p><ol><li>测试服务器网速时显示0M/s，去前面更换协议就行，多试几个</li><li>在购买的服务器上把常用的端口都打开，具体做法百度以下就行，很简单，在域名管理里面的防火墙设置里面</li><li>实在搞不出来的可以多看看其他博客，相互映照，也可以给自己放个假，隔两天再来。不要害怕失败，我当初也是搞了十几天才成功搭建出来的，当初我也是一个纯小白入手，遇到的坑数不胜数，回想起来都一脸辛酸泪呀，不过这个过程还是很有意义的，很能锻炼我们自主学习的能力的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 自主学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> self-learning、科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+butterfly博客学习</title>
      <link href="/2022/07/14/hexo+butterfly%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/14/hexo+butterfly%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分：完成一个博客上传"><a href="#第一部分：完成一个博客上传" class="headerlink" title="第一部分：完成一个博客上传"></a>第一部分：完成一个博客上传</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先的在一个空文件夹里面初始化hexo环境，具体做法：点开空文件夹，鼠标右键点击git bash here，然后输入命令 hexo init和hexo install即可完成环境初始化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">hexo install</span><br></pre></td></tr></table></figure><h2 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h2><p>完成初始化后我们转到所在目录即可进行接下来的操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd +目录名</span><br></pre></td></tr></table></figure><p>接下来我们新建一个博客，输入命令“hexo new 第一篇博客”即可生成初始文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new 第一篇博客</span><br></pre></td></tr></table></figure><h2 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h2><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: test</span><br><span class="line">date: 2022-07-14 16:53:45</span><br><span class="line">tags: self-learning </span><br><span class="line">categories:</span><br><span class="line">- learning</span><br><span class="line">---</span><br><span class="line">摘要名称</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">接下来是文章摘要的正文内容</span><br></pre></td></tr></table></figure><p>包括博客里面重要的内容，如题目、作者、分类、标签等，这里需要注意的是空格，即在标点后面需要添加空格，如冒号： 空格 。这部分还可以添加文章的摘要，添加格式如上所述。</p><h3 id="资源引用"><a href="#资源引用" class="headerlink" title="资源引用"></a>资源引用</h3><p>当引用图片或其他形式的资源等，有以下两种方式解决：</p><p>1.使用绝对路径引用</p><p>2.使用相对路径引用</p><p>使用相对路径引用资源的时候，我们可以使用hexo提供的资源文件夹功能。</p><p>打开根目录下的_config.yml文件,将post_asset_folderde的值设为true</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>修改之后会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 <code>hexo new &lt;title&gt;</code> 命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。例如，你把一个 <code>example.jpg</code> 图片放在了这个同名文件夹中，使用相对路径的常规 markdown 语法 <code>![](./example.jpg)</code>即可访问 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](./式28.jpg)</span><br></pre></td></tr></table></figure><h2 id="文章上传"><a href="#文章上传" class="headerlink" title="文章上传"></a>文章上传</h2><h2 id="本地查看"><a href="#本地查看" class="headerlink" title="本地查看"></a>本地查看</h2><p>运行下列语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl或者hexo c或者hexo clean</span><br><span class="line">hexo g或者hexo generate(可省略)</span><br><span class="line">hexo s或者hexo server</span><br></pre></td></tr></table></figure><p>接下来访问它出现的<a href="http://localhost:4000">网址</a>即可查看最新更改的内容</p><h2 id="上传GitHub"><a href="#上传GitHub" class="headerlink" title="上传GitHub"></a>上传GitHub</h2><p>运行下列语句即可完成上传</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl或者hexo c或者hexo clean</span><br><span class="line">hexo g或者hexo generate</span><br><span class="line">hexo d或者hexo deploy</span><br></pre></td></tr></table></figure><p>上传后有延迟，需要等待几分钟后刷新网页才会出现新更改的内容。</p><p>PLus：上传的时候用校园网一直上传不上去，改用手机热点即可上传成功！！</p><hr><h1 id="第二部分：文章加密"><a href="#第二部分：文章加密" class="headerlink" title="第二部分：文章加密"></a>第二部分：文章加密</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p><code>npm install --save hexo-blog-encrypt</code></p><h2 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h2><ol><li><p>首先在站点配置文件中启动该插件，即打开根目录下的_congfig.yml文件修改以下选项</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encrypt:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure></li><li><p>然后再在front-matter中添加对应的字段，如password，abstract，message等</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 文章加密</span><br><span class="line">date: 2019-01-04T22:20:13.000Z</span><br><span class="line">category: 教程</span><br><span class="line">tags:</span><br><span class="line">  - 博客</span><br><span class="line">  - Hexo</span><br><span class="line">keywords: 博客文章密码</span><br><span class="line">password: TloveY</span><br><span class="line">abstract: 密码：TloveY</span><br><span class="line">message:  输入密码，查看文章</span><br></pre></td></tr></table></figure><ul><li>keyword: 关键字</li><li>password：密码</li><li>abstract：文章摘要</li><li>message：博客查看时，密码输入框上面的描述性文字</li></ul><hr><h1 id="第三部分：更改主题"><a href="#第三部分：更改主题" class="headerlink" title="第三部分：更改主题"></a>第三部分：更改主题</h1><h2 id="butterfly"><a href="#butterfly" class="headerlink" title="butterfly"></a>butterfly</h2><p>其实最好的使用提示就是查看其官方文档<a href="https://butterfly.js.org/">Butterfly</a></p><p>这里面已经很详细了，不过我在这还是简单地介绍一下大致流程可以帮我们更好地理解和使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>Git安装（GitHub）（稳定版）</p><p>在根目录下打开命令行或者右键选择Git Bash Here,接下来输入下列命令</p><p><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></p></li><li><p>Git安装（Gitee）（稳定版）</p><p>在根目录下打开命令行或者右键选择Git Bash Here,接下来输入下列命令</p><p><code>git clone -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</code></p></li></ol><p>3.npm安装<br>   在根目录下打开命令行或者右键选择Git Bash Here,接下来输入下列命令<br>   <code>npm i hexo-theme-butterfly</code></p><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改根目录下的_config.yml文件，把主题改为butterfly<br>   <code>theme:butterfly</code></p><h3 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h3><p>建议把这两条命令都运行一次<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><h3 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h3><p>在根目录下创建_config.butterfly.yml文件，并把themes文件夹下的butterfly子文件中的_congfig.yml内容复制到所创建的_config.butterfly.yml文件中去，注意这里的_config.yml文件不是根目录下的那个。完成后hexo会自动合并主题中的_config.yml文件和_config.butterfly.yml（优先级更高）文件中的配置</p><h3 id="主题使用建议pages"><a href="#主题使用建议pages" class="headerlink" title="主题使用建议pages"></a>主题使用建议pages</h3><p>详细阅读_config.butterfly.yml文件中的内容，里面重要的设置都有备注，不懂的地方可以跟着官方文档<a href="https://butterfly.js.org/posts/dc584b87/">butterfly</a>过一遍应该就差不多懂了</p><h1 id="自定义博客封面和背景"><a href="#自定义博客封面和背景" class="headerlink" title="自定义博客封面和背景"></a>自定义博客封面和背景</h1><p>有两种方式可以设置封面和背景，一种是在_congfig.butterfly.yml文件里修改，另一种是在每个博客的front-matter中定义，在这我推荐第二种方式，可以每篇文章设置不同的封面和背景</p><p>在front-matter中添加内容如下：</p><ul><li><p><code>top_img: 图片地址</code>  博客顶端背景</p></li><li><p><code>cover: 图片地址</code>文章封面</p></li></ul><h1 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h1><p>为了方便更好地访问我们的博客，我们可以在国内买一个域名（便宜的几块钱一年）绑定到我们的github上即可，具体步骤如下：</p><ol><li><p>在GitHub上打开你博客的所在项目，然后在setting—&gt;pages—&gt;custom domain输入你购买的域名，然后save即可</p></li><li><p>在根目录下的source文件夹下新建一个CNAME文件（没有后缀名），然后把你的域名填进去就行</p></li><li><p>修改根目录下的_config.yml文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render: CNAME</span><br></pre></td></tr></table></figure></li></ol><p>之后正常上传就好了</p>]]></content>
      
      
      <categories>
          
          <category> 自主学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> self-learning、博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
