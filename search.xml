<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法学习之决策树(一)：算法原理及实例</title>
      <link href="/2022/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE/"/>
      <url>/2022/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了加强自身有关机器学习理论基础，现重新梳理一下机器学习主流算法的理论知识以及其实践细节。现在分别整理如下：</p><ul><li>决策树</li><li>随机森林</li><li>Adaboost</li><li>GBDT</li><li>logistic回归</li><li>SVM</li><li>朴素贝叶斯</li><li>XGboost</li><li>lightgbm</li></ul><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树是一个有监督分类与回归算法。决策树的生成只考虑局部最优，相对的，决策树剪枝则考虑全局最优。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>决策树是一种基本的分类与回归方法，其模型就是用一棵树来表示我们的整个决策过程。这棵树可以是二叉树（比如CART 只能是二叉树），也可以是多叉树（比如 ID3、C4.5 可以是多叉树或二叉树）。根节点包含整个样本集，每个叶节都对应一个决策结果（注意，不同的叶节点可能对应同一个决策结果），每一个内部节点都对应一次决策过程或者说是一次属性测试。从根节点到每个叶节点的路径对应一个判定测试序列。<br>决策树的生成就是不断的选择最优的特征对训练集进行划分，是一个递归的过程。递归返回的条件有三种：</p><ol><li>当前节点包含的样本属于同一类别，无需划分；</li><li>当前属性集为空，或所有样本在属性集上取值相同，无法划分；</li><li>当前节点包含样本集合为空，无法划分。</li></ol><hr><h2 id="ID3、C4-5、CART"><a href="#ID3、C4-5、CART" class="headerlink" title="ID3、C4.5、CART"></a>ID3、C4.5、CART</h2><p>这是三个非常著名的决策树算法，简单来说：</p><ul><li>ID3 使用信息增益作为选择特征的准则；</li><li>C4.5 使用信息增益比作为选择特征的准则；</li><li>CART 使用 Gini 指数作为选择特征的准则。</li></ul><h3 id="熵-entropy"><a href="#熵-entropy" class="headerlink" title="熵(entropy)"></a>熵(entropy)</h3><p>表示随机变量不确定性的度量。</p><p>设X 是一个有限状态的离散型随机变量，其概率分布为:<br>$P(X=x_i)=p_i,\,\,i=1,2,\cdot,n$<br>则随机变量X熵定义为:</p><p>$H(X)=-\sum_{i=1}^np_i*log(p_i)$</p><p>熵越大，则随机变量的不确定性越大。<br>熵表示的是数据中包含的信息量大小。熵越小，数据的纯度越高，也就是说数据越趋于一致，这是我们希望的划分之后每个子节点的样子。</p><h3 id="条件熵-conditional-entropy-："><a href="#条件熵-conditional-entropy-：" class="headerlink" title="条件熵(conditional entropy)："></a>条件熵(conditional entropy)：</h3><p>随机变量X给定的条件下，随机变量Y的条件熵H(Y|X)定义为：<br>$H(Y|X)=\sum_{i=1}^np_i*H(Y|X=x_i)$<br>其中，$p_i=P(X=x_i)$。</p><h3 id="信息增益-information-gain-："><a href="#信息增益-information-gain-：" class="headerlink" title="信息增益(information gain)："></a>信息增益(information gain)：</h3><p>意义：引入属性A后，原来数据集D的不确定性减少了多少。<br>定义属性A对数据集D的信息增益为$g(D,A)$，它等于D本身的熵减去给定A的条件下D的条件熵，即<br>$g(D,A)=H(D)-H(D|A)$<br>一般地，熵$H(Y)$与条件熵$H(Y|X)$之差称为互信息(mutual information)。<br>信息增益越大，则意味着使用属性a来进行划分所获得的 “纯度提升” 越大 。也就是说，用属性a来划分训练集，得到的结果中纯度比较高。</p><h3 id="基尼指数（Gini-index）"><a href="#基尼指数（Gini-index）" class="headerlink" title="基尼指数（Gini index）"></a>基尼指数（Gini index）</h3><p>假设数据集D中有K个类，样本属于第K类的概率为pk，基尼指数Gini(D)表示集合D的不确定性(纯度)，公式如下：</p><script type="math/tex; mode=display">Gini（D）=\sum_{i=1}^Np_k*(1-p_k)=1-\sum_{i=1}^Np_k^2</script><p>从上面的公式可以发现，当数据集D中只有1个类时，pk=1，Gini(D)=0，说明基尼指数越小，样本纯度越高。<br>对于特征A，将集合D划分成D1和D2，基尼指数Gini(D,A)表示经过A=a划分后集合D的不确定性，公式如下：</p><script type="math/tex; mode=display">Gini(D,A)= {|D_1|\over|D|}*Gini(D_1)+{|D_2|\over|D|}*Gini(D_2)</script><p>其中|D|、|D1|、|D2|分别表示数据集D、D1、D2中样本数量。</p><h3 id="误差平方和"><a href="#误差平方和" class="headerlink" title="误差平方和"></a>误差平方和</h3><p>在预测模型时希望真实值和预测值越接近越好，说明预测误差小。若yi表示训练集D={(x1,y1),(x2,y2),…,(xn,yn)}的输出变量，是连续值。f(xi)是预测值，则预测误差可以表示为：<br>$err=\sum[y<em>i-f(x_i)]^2$<br>我们拟合的目标就是寻找最佳划分特征里的最佳划分点，找到每一个f(xi)，使得误差平方和最小化。<br>计算各个特征各个值划分的两部分 和D1和D2 的误差平方和，选择误差平方和最小的（如下式）作为最优特征和最优切分点<br>$\min_j,s[min</em>{c1}\sum<em>{x_i\epsilon R_1(j,s)}(y_i-c1)^2+min</em>{c2}\sum_{x_i\epsilon R_2(j,s)}(y_i-c2)^2]$<br>上面的j是不同的特征，s是对应每个特征可供选择的划分点，因为一个连续特征的值很多，所以划分点很多，要选择最优的。<br>中括号内的意思就是找出针对特征j的最优划分点s，采用均方误差，最外层是特征，计算不同特征。回归的比分类相对麻烦一些，分类只需要计算每个特征的信息增益，回归是计算每个特征的均方误差增益，但是它多了一个步骤就是求每个特征增益的时候还要找出最优划分值s。</p><hr><h2 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h2><p>ID3 使用信息增益作为选择特征的准则，<strong>信息增益 = 划分前熵 - 划分后熵</strong>。信息增益越大，则意味着使用属性a来进行划分所获得的 “纯度提升” 越大 。也就是说，用属性a来划分训练集，得到的结果中纯度比较高</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>从根节点开始，计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的划分特征；</li><li>由该特征的不同取值建立子节点；</li><li>再对子节点递归1-2步，构建决策树；</li><li>直到没有特征可以选择或类别完全相同为止，得到最终的决策树。</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据；缺点：</p><ul><li>只能处理分类属性的数据，不能处理连续的数据；</li><li>没有剪枝，可能会产生过度匹配问题，需要进行剪枝</li><li>采用信息增益作为选择最优划分特征的标准，然而信息增益会偏向那些取值较多的特征</li></ul><hr><h2 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h2><p>C4.5 克服了 ID3 仅仅能够处理离散属性的问题，以及信息增益偏向选择取值较多特征的问题，使用信息增益比来选择特征。<strong>信息增益比 = 信息增益 / 划分前熵</strong>。选择信息增益比最大的作为最优特征。公式：<br>$gR(D,A)={g(D,A)\over H<em>A(D)}$<br>其中  $H_A(D)=-\sum</em>{i=1}^n{|D_i|\over|D|}*log2({|D_i|\over|D|})$， n 是特征 A 取值的个数<br>C4.5 处理连续特征是先将特征取值排序，以连续两个值中间值作为划分标准。尝试每一种划分，并计算修正后的信息增益，选择信息增益最大的分裂点作为该属性的分裂点。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：<br>（1）通过信息增益率选择分裂属性，克服了ID3算法中通过信息增益倾向于选择拥有多个属性值的属性作为分裂属性的不足；<br>（2）能够处理离散型和连续型的属性类型，即将连续型的属性进行离散化处理；<br>（3）构造决策树之后进行剪枝操作；<br>（4）能够处理具有缺失属性值的训练数据。<br>缺点：<br>（1）算法的计算效率较低，特别是针对含有连续属性值的训练样本时表现的尤为突出。<br>（2）算法在选择分裂属性时没有考虑到条件属性间的相关性，只计算数据集中每一个条件属性与决策属性之间的期望信息，有可能影响到属性选择的正确性。</p><h2 id="CART（分类回归树）"><a href="#CART（分类回归树）" class="headerlink" title="CART（分类回归树）"></a>CART（分类回归树）</h2><h3 id="决策树的思想"><a href="#决策树的思想" class="headerlink" title="决策树的思想"></a>决策树的思想</h3><p>决策树认为，物以类聚、人以群分，在特征空间里相近的样本，那就是一类。如果为每个“类”分配的空间范围比较小，那么，同一个类内的样本差异会非常小，以至于看起来一样。换句话说，如果我们可以将特征空间切分为较小的碎块，然后为每一个碎块内的样本配置一个统一的因变量取值，就有机会做出误差较小的预测。这也是分类和聚类算法的基本假设。</p><p>它的做法比较粗暴：首先分割特征空间，也就是将样本分组；然后为每一组样本分配一个预测值；最后，在预测阶段，为样本找到分组、找到预测值。</p><p>这种思想似乎有点道理，值得一试。当然有2个问题需要回答：（1）如何切分特征空间；（2）如何为各个空间碎块设置因变量取值。</p><h3 id="针对离散数据的分类决策树"><a href="#针对离散数据的分类决策树" class="headerlink" title="针对离散数据的分类决策树"></a>针对离散数据的分类决策树</h3><p>假设预测任务的输入和输出都是离散值，我们可以直接以特征的各个取值为候选分割平面（换个说法，就是对训练样本分组），进行决策树的构建——这就是针对离散值的分类决策树。</p><p>注意，针对离散值的决策树在对训练样本进行分组时，一般情况下不允许重复使用一个特征。而有能力处理连续变量的CART回归树不同，允许重复使用一个特征。</p><h3 id="CART回归树的逻辑结构"><a href="#CART回归树的逻辑结构" class="headerlink" title="CART回归树的逻辑结构"></a>CART回归树的逻辑结构</h3><p>当然，一些情况下，部门不能直接使用特征取值，比如说，特征为连续变量。这时候，我们需要使用一种新的策略，来选择用于分割样本的特征取值。</p><p>另一种情况下，我们不能使用信息增益、基尼系数这样的指标，作为分组质量的表征——输出值是连续变量。这时候，我们也需要一种新的策略，来评估分组质量。</p><p>当任务的输出值为连续变量，我们需要使用决策树的另一种版本——回归树。最常见的回归树就是CART回归树。</p><h2 id="实例演示计算"><a href="#实例演示计算" class="headerlink" title="实例演示计算"></a>实例演示计算</h2><div class="table-container"><table><thead><tr><th></th><th>天气</th><th>温度</th><th>湿度</th><th>风速</th><th>活动</th></tr></thead><tbody><tr><td>1</td><td>晴</td><td>炎热</td><td>高</td><td>弱</td><td>取消</td></tr><tr><td>2</td><td>晴</td><td>炎热</td><td>高</td><td>强</td><td>取消</td></tr><tr><td>3</td><td>阴</td><td>炎热</td><td>高</td><td>弱</td><td>进行</td></tr><tr><td>4</td><td>雨</td><td>适中</td><td>高</td><td>弱</td><td>进行</td></tr><tr><td>5</td><td>雨</td><td>寒冷</td><td>正常</td><td>弱</td><td>进行</td></tr><tr><td>6</td><td>雨</td><td>寒冷</td><td>正常</td><td>强</td><td>取消</td></tr><tr><td>7</td><td>阴</td><td>寒冷</td><td>正常</td><td>强</td><td>进行</td></tr><tr><td>8</td><td>晴</td><td>适中</td><td>高</td><td>弱</td><td>取消</td></tr><tr><td>9</td><td>晴</td><td>寒冷</td><td>正常</td><td>弱</td><td>进行</td></tr><tr><td>10</td><td>雨</td><td>适中</td><td>正常</td><td>弱</td><td>进行</td></tr><tr><td>11</td><td>晴</td><td>适中</td><td>正常</td><td>强</td><td>进行</td></tr><tr><td>12</td><td>阴</td><td>适中</td><td>高</td><td>强</td><td>进行</td></tr><tr><td>13</td><td>阴</td><td>炎热</td><td>正常</td><td>弱</td><td>进行</td></tr><tr><td>14</td><td>雨</td><td>适中</td><td>高</td><td>强</td><td>取消</td></tr></tbody></table></div><p>数据集中有四个属性（天气、温度、湿度、风速），类标签有两个（进行和取消）。</p><p>plus：我们只关注最后的结果是进行还是取消，所以我们在任何分类属性下都只关注类标签的概率，这一点很重要，不然后面都不知道为什么这么计算。</p><h3 id="1-计算类别信息熵"><a href="#1-计算类别信息熵" class="headerlink" title="1. 计算类别信息熵"></a>1. 计算类别信息熵</h3><p>类别信息熵表示的是所有样本中各种类别出现的不确定性之和。根据熵的概念，熵越大，不确定性就越大，把事情搞清楚所需要的信息量就越多。</p><p>按照上文中的公式，我们可以计算在同一属性下的类别信息熵（plus：可能说的不对，但是大概意思是计算在这个属性分类下的类别信息熵，这里突出的是计算同一属性或分类下，其他分类下的类别信息熵则不用管。当没有分类的时候则计算整个数据集下的类别信息熵，计算过程如下）。</p><script type="math/tex; mode=display">H(D)=-9/14*log2(9/14)-5/14*1og2(5/14)=0.940</script><p>其中，9/14是整个数据集下的类标签“进行”的概率，5/14是整个数据集下的类标签“取消”的概率</p><h3 id="2-计算每个属性的信息熵"><a href="#2-计算每个属性的信息熵" class="headerlink" title="2. 计算每个属性的信息熵"></a>2. 计算每个属性的信息熵</h3><p>每个属性的信息熵相当于一种条件熵。他表示的是在某种属性的条件下，各种类别出现的不确定性之和。属性的信息熵越大，表示这个属性中拥有的样本类别越不“纯”。</p><p>每个属性就相当于按照一定的规则进行了一次分类，在例子中，我们分别对数据集中的四个属性进行初步分类就可以得出每个属性的信息熵。</p><script type="math/tex; mode=display">H(天气)=5/14*[-2/5*log2(2/5)-3/5*log2(3/5)]+4/14*[-4/4*log2(4/4)]+5/14*[-3/5*log2(3/5)-2/5*log2(2/5)]=0.694</script><p>其中，天气的信息熵为晴天的概率（5/14）乘以晴天条件下类别信息熵$[-2/5<em>log2(2/5)-3/5</em>log2(3/5)]$加上阴天的概率（4/14）乘以阴天条件下的类别信息熵$[-4/4<em>log2(4/4)]$加上雨天的概率（5/14）乘以雨天条件下的类别信息熵$[-3/5</em>log2(3/5)-2/5*log2(2/5)]$。同理：</p><script type="math/tex; mode=display">H(温度)=0.911\\H（湿度）=0.789\\H（风速）=0.892</script><h3 id="3-计算信息增益-ID3"><a href="#3-计算信息增益-ID3" class="headerlink" title="3. 计算信息增益 (ID3)"></a>3. 计算信息增益 (ID3)</h3><p>信息增益的 = 熵 - 条件熵，在这里就是类别信息熵 - 属性信息熵，它表示的是信息不确定性减少的程度。如果一个属性的信息增益越大，就表示用这个属性进行样本划分可以更好的减少划分后样本的不确定性，当然，选择该属性就可以更快更好地完成我们的分类目标。</p><p>信息增益就是ID3算法的特征选择指标。</p><script type="math/tex; mode=display">g(D,天气)=H（D）-H（天气）=0.246\\g(D,温度)=H（D）-H（温度）=0.029\\g(D,湿度)=H（D）-H（湿度）=0.15\\g(D,风速)=H（D）-H（风速）=0.048</script><p>这里选择最大的信息增益作为根节点，然后再确定这个根节点下再重复过程1~3，确定接下来的各个子跟节点，直到没有特征可以选择或类别完全相同为止，得到最终的决策树。</p><h3 id="4-计算属性分裂信息度量"><a href="#4-计算属性分裂信息度量" class="headerlink" title="4. 计算属性分裂信息度量"></a>4. 计算属性分裂信息度量</h3><p>用分裂信息度量来考虑某种属性进行分裂时分支的数量信息和尺寸信息，我们把这些信息称为属性的内在信息（instrisic information）。信息增益率用<strong>信息增益 / 内在信息</strong>，会导致属性的重要性随着内在信息的增大而减小（也就是说，如果这个属性本身不确定性就很大，那我就越不倾向于选取它），这样算是对单纯用信息增益有所补偿。</p><script type="math/tex; mode=display">H_A（天气）=-5/14*log2（5/14）-4/14*log2（4/14）-5/14*log（5/15）=1.577\\H_A（温度）=1.556\\H_A（湿度）=1.0\\H_A（风速）=0.985</script><h3 id="5-计算信息增益率（C4-5"><a href="#5-计算信息增益率（C4-5" class="headerlink" title="5. 计算信息增益率（C4.5)"></a>5. 计算信息增益率（C4.5)</h3><script type="math/tex; mode=display">gR（天气）=g(D,天气)/H_A（天气）=0.155\\gR（温度）=g(D,温度)/H_A（温度）=0.0186\\gR（湿度）=g(D,湿度)/H_A（湿度）=0.151\\gR（风速）=g(D,风速)/H_A（风速）=0.048\\</script><p>天气的信息增益率最高，选择天气为分裂属性。发现分裂了之后，天气是“阴”的条件下，类别是”纯“的，所以把它定义为叶子节点，选择不“纯”的结点继续分裂。在子结点当中重复过程1~5。</p><h3 id="6-计算基尼指数-（CART分类）"><a href="#6-计算基尼指数-（CART分类）" class="headerlink" title="6. 计算基尼指数 （CART分类）"></a>6. 计算基尼指数 （CART分类）</h3><p>计算各特征的基尼质数，选择最优特征以及最优切分点。</p><p>以求特征属性天气的基尼质数为例，其中|D|表示整个数据集中样本个数14，$|D_1|$表示天气为晴的样本个数，$|D_2|$表示天气不为晴的样本个数。</p><script type="math/tex; mode=display">Gini(D,天气=晴)={5\over14}*[2*{2\over5}*{3\over5}]+{9\over14}*[2*{7\over9}*{2\over9}]=0.394</script><p>其中${5\over14}$为晴天的概率，$ [2<em>{2\over5}</em>{3\over5}] $为晴天条件下的基尼指数，$[2<em>{7\over9}</em>{2\over9}]$为不是晴天条件下的基尼指数。同理：<br>$Gini(D,天气=阴)={4\over14}<em>[2</em>{4\over4}<em>{0\over4}]+{10\over14}</em>[2<em>{5\over10}</em>{5\over10}]=0.357$</p><p>$Gini(D,天气=雨)={5\over14}<em>[2</em>{2\over5}<em>{3\over5}]+{9\over14}</em>[2<em>{6\over9}</em>{3\over9}]=0.457$</p><p>$Gini(D,温度=炎热)={4\over14}<em>[2</em>{2\over4}<em>{2\over4}]+{10\over14}</em>[2<em>{7\over10}</em>{3\over10}]=0.443$</p><p>$Gini(D,温度=适中)={6\over14}<em>[2</em>{2\over6}<em>{4\over6}]+{8\over14}</em>[2<em>{5\over8}</em>{3\over8}]=0.472$</p><p>$Gini(D,温度=寒冷)={4\over14}<em>[2</em>{1\over4}<em>{3\over4}]+{10\over14}</em>[2<em>{6\over10}</em>{4\over10}]=0.45$</p><p>$Gini(D,湿度=高)={7\over14}<em>[2</em>{4\over7}<em>{3\over7}]+{7\over14}</em>[2<em>{6\over7}</em>{1\over7}]=0.367$</p><p>$Gini(D,湿度=正常)={7\over14}<em>[2</em>{4\over7}<em>{3\over7}]+{7\over14}</em>[2<em>{6\over7}</em>{1\over7}]=0.367$</p><p>$Gini(D,风速=弱)={8\over14}<em>[2</em>{6\over8}<em>{2\over8}]+{6\over14}</em>[2<em>{3\over6}</em>{3\over6}]=0.429$</p><p>$Gini(D,风速=弱)={8\over14}<em>[2</em>{6\over8}<em>{2\over8}]+{6\over14}</em>[2<em>{3\over6}</em>{3\over6}]=0.429$</p><p>由上面计算可知：Gini(D,天气=阴)=0.357最小，则选择阴天为最优特征，是否为阴天为最优切分点，依次计算划分值，重复此过程可生成最后的决策树。</p><h3 id="7-计算残差平方和（CART回归）"><a href="#7-计算残差平方和（CART回归）" class="headerlink" title="7.计算残差平方和（CART回归）"></a>7.计算残差平方和（CART回归）</h3><p>算法流程：</p><ol><li><p>选择最优切分特征j和切分点s</p><p>$\min<em>j,s[min</em>{c1}\sum<em>{x_i\epsilon R_1(j,s)}(y_i-c1)^2+min</em>{c2}\sum_{x_i\epsilon R_2(j,s)}(y_i-c2)^2]$</p></li><li><p>用选定的对（j，s）划分区域并决定相应的输出值：</p><p>$R_1(j,s)={x|x^{(j)}&lt;=s}   R_2(j,s)={x|x^{(j)}&gt;s} $</p><p>$c<em>m={1\over N_m}\sum</em>{x_i\epsilon R_m(j,s)}y_i\,\,\, x\epsilon R_m,m=1,2$</p><p>第一个式子是将数据按照切分点分成两个节点，第二个是求每个节点的均方误差之和。</p></li><li><p>继续对两个子区域调用步骤1，2直至满足停止条件</p></li><li><p>将输入空间划分为M个区域， $R_1$ , $R_2$ , . . . $R_M$ 生成决策树：</p><p>$f(x)=\sum_{i=1}^Mc_mI (x\epsilon R_m)$</p><p>该式子的意思是求分到相同节点的均值作为预测值，后面的指示函数作为划分到那么区域。</p></li></ol><div class="table-container"><table><thead><tr><th>x</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>y</td><td>5.56</td><td>5.7</td><td>5.91</td><td>6.4</td><td>6.8</td><td>7.05</td><td>8.9</td><td>8.7</td><td>9</td><td>9.05</td></tr></tbody></table></div><p>该式子的意思是求分到相同节点的均值作为预测值，后面的指示函数作为划分到那么区域。</p><p>特征x包含了10个元素，且已排好序了，直接以(xi+xi+1)/2，i∈{1,2,…,10}为切分点s，容易求得:</p><p>$R_1{x|x^&lt;=s}\,\,\, R_2={x|x&gt;s} $</p><p>则C1、C2为：</p><p>$c<em>1={1\over N_1}\sum</em>{x<em>i\epsilon R_1}y_i\,\,\,c_2={1\over N_2}\sum</em>{x_i\epsilon R_2}y_i $</p><p>其中N1、N2分别是R1、R2中的样本点数，C1、C2为R1、R2中的因变量均值。</p><p>针对x考虑如下切分点：1.5、2.5、3.5、4.5、5.5、6.5、7.5、8.5、9.5，可以求出相应的R1、R2、C1、C2，以及  $\min<em>j,s[min</em>{c1}\sum<em>{x_i\epsilon R_1(j,s)}(y_i-c1)^2+min</em>{c2}\sum_{x_i\epsilon R_2(j,s)}(y_i-c2)^2]$</p><p>例如，当s=1.5时，R1={1}，R2={2,3,…,10}，C1=5.56，C2=7.5，则</p><p>$m(s)=\min<em>j,s[min</em>{c1}\sum<em>{x_i\epsilon R_1(j,s)}(y_i-c1)^2+min</em>{c2}\sum_{x_i\epsilon R_2(j,s)}(y_i-c2)^2]=0+15.72=15.72$</p><p>同理可得其它划分点的最小误差如下：</p><div class="table-container"><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th><th>6.5</th><th>7.5</th><th>8.5</th><th>9.5</th></tr></thead><tbody><tr><td>m(s)</td><td>15.72</td><td>12.07</td><td>8.36</td><td>5.78</td><td>3.91</td><td>1.93</td><td>8.01</td><td>11.73</td><td>15.74</td></tr></tbody></table></div><p>由上表知，当x=6.5时m(s)达到最小值，即此时误差平方和最小。此时R1={1,2,…,6}，R2={7,8,…,10}，C1=6.24、C2=8.9，所以回归树T1(x)为:</p><script type="math/tex; mode=display">f_1(x)=T_1(x)= \begin{cases}6.24.x<6.5\\8.91,x>6.5\end{cases}</script><p>用f1(x)拟合训练数据的残差见下表，表中r2i= yi- f1(xi) (i=1,2,…1,10)。</p><div class="table-container"><table><thead><tr><th>x</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>r2i</td><td>-0.68</td><td>-0.54</td><td>-0.33</td><td>0.16</td><td>0.56</td><td>0.81</td><td>-0.01</td><td>-0.21</td><td>0.09</td><td>0.14</td></tr></tbody></table></div><p>第2步求T2(x)方法与求T1(x)，只是拟合的数据是上表的残差，可以得到</p><script type="math/tex; mode=display">T_2(x)= \begin{cases}-0.52,x<3.5\\0.22,x>=6.5\end{cases}</script><script type="math/tex; mode=display">f_2(x)=f_1(x)+T_2(x)= \begin{cases}5.72,x<3.5\\6.46,3.5<=x<6.5\\ 9.13,x>=6.5\end{cases}</script><p>可以根据此方法继续求解，直至拟合训练数据的误差平方和小于某个阈值时作为结束条件，那么f(x)=fi(x)即为所求回归树。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习，决策树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python复习日记</title>
      <link href="/2022/07/23/python%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>/2022/07/23/python%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="大厂复习日记python篇-–day-1-2022-7-23"><a href="#大厂复习日记python篇-–day-1-2022-7-23" class="headerlink" title="大厂复习日记python篇   –day 1 2022-7-23"></a>大厂复习日记python篇   –day 1 2022-7-23</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>###声明：这是一个复习blog，记录复习过程中的各种题库。资料由于是在网上收集的，所以可能出现各种大范围雷同。如果侵犯您的版权，请评论留言，我会第一时间做出相应调整。在此，特别鸣谢：Java架构师必看的<a href="https://zhuanlan.zhihu.com/p/270331009">进大厂必须掌握的面试题-100个python面试</a>###</p><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98">基本面试问题</a></li><li><a href="#OOPS%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98">OOPS面试问题</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84python%E7%A8%8B%E5%BA%8F">基本的python程序</a></li><li><a href="#python%E5%BA%93">python库</a></li></ul><h2 id="基本面试问题"><a href="#基本面试问题" class="headerlink" title="基本面试问题"></a>基本面试问题</h2><ol><li><p>python中的列表和元组有什么区别？、</p><ul><li><p>列表中的元素可以修改，元组中的元素不可修改，除非整个元组替换掉！</p></li><li><p>元组比列表更加轻量级，性能速度优于列表</p></li><li><p>元组可以在映射中当“键”使用，列表不能</p></li></ul></li><li><p>python主要功能是什么？</p><ul><li>python是一种解释型语言，与c语言不同，不需要编译</li><li>python是动态类型的，不需要声明变量的类型</li><li>python适合面向对象编程，因为它允许定义类以及组成和继承。python没有访问说明（如C++的public，private）（访问说明就是设置一个访问权限，不同人有着不同的权限）</li><li>编写代码速度快，但运行时比编译语言要慢，但python允许C的扩展，可以很大部分消除瓶颈</li><li>python有很多库，可以快速实现某项功能和解决某个问题</li></ul></li><li><p>python是一种什么类型的语言？编程还是脚本？</p><p>python能够编写脚本，但一般认为他是通用编程语言</p></li><li><p>python是一种解释语言吗？</p><p>python是一种解释型语言。（解释型语言是指运行之前不需要编译，在运行时执行一句翻译一句为机器语言）</p></li><li><p>什么是pep 8？</p><p>PEP代表python增强建议书（PEP8：python编程规范）。这是一组规则，用于指定如何格式化python代码以实现最大的可读性。</p></li><li><p>如何在python中管理内存？</p><p>Python引用了一个内存池(memory pool)机制，即Pymalloc机制(malloc:n.分配内存)，用于管理对小块内存的申请和释放。</p><p>主要有三种机制：</p><ul><li>引用计数机制。python内部使用引用计数，来保持追踪内存中的对象，python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。</li><li>垃圾回收机制。当内存中有不再使用的部分时（引用数为0），垃圾收集器就会把他们清理掉。它会去检查那些引用计数为0的对象，然后清除其在内存的空间；循环垃圾回收器（a引用b，b引用a，这种相互引用也会被清除）。</li><li>内存池机制。内存池的概念就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。python引入内存池机制用于管理小块内存的申请和释放；同时，python将释放的内存返回给内存池，而不是操作系统；对于python对象（整数，浮点数和list等）有着独有的私有内存池，不同对象的内存池不共享。</li></ul></li><li><p>python的命名空间是什么？</p><p>命名空间是用于确保名称唯一以确保命名冲突的命名系统</p></li><li><p>什么是pythonpath？<br>这是一个环境变量，在导入模块时使用。当导入模块的时候，都会查找pythonpath以检查各个目录中是否存在导入的模块，解释器使用它来确定要加载哪个模块。</p></li><li><p>什么是python模块？命名python中一些常用的内置模块？<br>python模块是包含python代码的文件。该代码可以是函数类或者变量。python模块是包含可执行代码的.py文件<br>一些常用的内置模块是：</p><ul><li>操作系统-OS</li><li>系统-sys</li><li>数学-math</li><li>随机-random</li><li>资料时间-data time</li><li>JSON格式</li></ul></li><li><p>python中的局部变量和全局变量是什么？<br>全局变量：在函数外部或全局空间声明的变量，可被程序中的任何函数访问<br>局部变量：在函数内部声明的变量，只能在函数局部空间内被访问</p></li><li><p>python是否区分大小写？<br>是的，区分。</p></li><li><p>什么是python中的类型转换？<br>类型转换是将一种数据转换为另一种数据类型。</p></li></ol><ul><li>int（） 转换为整数类型</li><li>float（） 转换为浮点数</li><li>ord（） 将字符转换为整数</li><li>hex（） 整数转换为十六进制</li><li>oct（） 整数转换为八进制</li><li>tuple（） 转换为元组</li><li>set（） 转换为集合后返回类型</li><li>list（） 转换为列表</li><li>dict（）此函数用于将顺序（键，值）的元组转换为字典</li><li>str（） 转换为字符串</li></ul><ol start="13"><li><p>如何在windows上安装python并设置路径变量？<br>从<a href="www.python.org">官网</a>上下载安装包，并按照提示符安装。<br>将安装路径添加到环境变量中（如点击计算机-&gt;属性-&gt;高级-&gt;环境变量-&gt;修改系统变量 path）</p></li><li><p>python是否需要缩进？<br>需要的，一般使用tab键缩进（四个空格）</p></li><li><p>python数组和列表有什么区别？<br>数组中的数据类型必须相同，列表则可以有多个数据类型元素。</p></li><li><p>python中的函数是什么？<br>是通过def语句定义的代码块，包含函数名，参数列表和函数体。</p></li><li><p>什么是init？<br>init是Python中的方法或构造函数。创建类的新对象/实例时，将自动调用此方法以分配内存。所有类都具有init方法。</p></li><li><p>什么是lambda函数？<br>匿名函数被称为lambda函数，此函数可以有任何数量的参数，但只能有一个语句</p></li><li><p>python中的self是什么？<br>self是类的实例或对象。在python中，这包括为第一个参数。init方法中的self变量引用新创建的对象，而其他方法中的self变量引用其方法被调用的对象。</p></li><li><p>什么是break、continue和pass？</p></li></ol><ul><li>break：跳出当前循环</li><li>continue： 跳出本次循环，后面语句不再执行</li><li>pass：主要用于占位</li></ul><ol start="21"><li><p>[::-1]是做什么的？<br>用于逆序输出，原始数组或者列表保持不变。</p></li><li><p>如何在python中将列表项随机化？<br>利用random库中的相关函数实现相关功能。</p></li><li><p>什么是python迭代器？<br>迭代器是可以遍历或迭代的对象。</p></li><li><p>如何在python中生成随机数？<br>调用random库中的相关函数。如：</p></li></ol><p>   random.random()  返回[0,1)范围内的随机浮点数。</p><ol start="25"><li><p>range()和xrange()有什么区别吗？<br>功能基本一致，但xrange（）对内存使用更加友好一点</p></li><li><p>如何在python中写注释？<br>使用#注释，有时候也可以用三引号引起来的字符串进行注释。</p></li><li><p>什么是**pickling和unpickling**？<br>pickle模块接受任何python对象并将其转换为字符串表示形式，并使用转储函数将其转储到文件中，此过程称之为pickling，从存储的字符串表示形式检索原始python对象的过程称为unpickling。</p></li><li><p>python中的生成器什么？<br>返回可迭代项目集的函数称为生成器。</p></li><li><p>如何大写字符串的第一个字母？<br>capitalize（）函数将字符串的首字母大写。</p></li><li><p>如何将字符串全部小写？<br>lower（）函数</p></li><li><p>如何在python中注释多行？<br>每行都要以#开头，不过jupyter 或pycharm有快捷键ctrl+/</p></li><li><p>python中的文档字符串是什么？<br>文档字符串用三引号引起来，没有被分配任何变量，有注释作用。</p></li><li><p>操作符和操作符的目的是什么？<br>可分为运算符和分隔符。运算符是特殊功能。它们采用一个或多个值并产生相应的结果。</p></li><li><p>python中的help（）和dir（）函数的用法是什么？<br>Help（）和dir（）这两个函数都可以从Python解释器访问，并用于查看内置函数的合并转储。Help（）函数：help（）函数用于显示文档字符串，还可以帮助您查看与模块，关键字，属性等有关的帮助；Dir（）函数：dir（）函数用于显示定义的符号。</p></li><li><p>当python退出时，为什么不取消分配所有内存？<br>那些具有对象循环引用或者全局命名空间引用的变量，在 Python 退出是往往不会被释放的，另外不会释放 C 库保留的部分内容。</p></li><li><p>python中的字典是什么？<br>python中的内置数据类型称为字典，它定义了键和值之间的一对一关系。字典包含一对键及其对应的值。字典由键索引。</p></li><li><p>如何在python中使用三元运算符？（这个我目前还不懂是啥）<br>三元运算符是用于显示条件语句的运算符。它由true或false值以及必须对其评估的语句组成。</p></li><li><p>*args,*kwargs是什么？有什么作用？<br>当我们不确定向函数传递多少参数时，或者将存储的参数列表或元组传递给函数时，可以使用*arges,* kwargs在我们不知道将多少个关键字参数传递给一个函数时使用，或者可用于将字典的值作为关键字参数传递</p></li><li><p>len()是做什么的？<br>确定字符串、列表、数组的长度</p></li><li><p>解释python中”re”模块的split（），sub（）、subn（）方法<br>为了修改字符串，Python的“ re”模块提供了3种方法：</p></li></ol><ul><li>split（）–使用正则表达式模式将给定的字符串“拆分”为列表</li><li>sub（）–查找所有与正则表达式模式匹配的子字符串，然后将其替换为其他字符串</li><li>subn（）–它类似于sub（），并且还返回新字符串以及no更换</li></ul><ol start="41"><li><p>什么是负索引，为什么要使用他们？<br>当遍历所索引序列时，可以从序列由前到后遍历，此时索引数为正，也是就正索引，同理当有后向前遍历序列时，索引数为负数，就是负索引，何时使用正索引还是负索引完全看具体情况哪种索引方便，一个从前往后数，一个从后往前数，方向不一致而已。</p></li><li><p>什么是python包？<br>python软件包是包含多个模块的名称空间</p></li><li><p>如何用python删除文件？<br>导入OS模块，使用<code>os.remove</code>即可</p></li><li><p>python的内置类型是什么？<br>python的内置类型如下：</p></li></ol><ul><li>Integers</li><li>Floating-point</li><li>Complex numbers</li><li>Strings</li><li>Boolean</li><li>Built-in functions</li></ul><ol start="45"><li><p>与python列表相比，numpy数组有什么优势？<br>相比来说，numpy不仅效率更高，而且更加方便。可以支持“向量化”操作，可以快速简单地实现矩阵和矢量运算；而且速度还更快，功能更加丰富。</p></li><li><p>如何将值添加到python数组组？<br>可以使用相关函数将元素添加到数组里面。如：append（），extend（），insert（i，x）。</p></li><li><p>如何删除值到python数组？<br>可以使用相关函数实现该功能。pop（）：返回删除值；remove（）：不返回删除值。</p></li><li><p>python是否具有OOps概念？<br>Python是一种面向对象的编程语言。这意味着可以通过创建对象模型在python中解决任何程序。但是，Python既可以当作过程语言，也可以当作结构语言。</p></li><li><p>深层复制和浅层复制有什么区别？<br>浅层复制：实现对象间数据元素的一一对应复制；深层复制：当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针所指对象进行复制。在python中，浅层复制会随原对象变化而变化，深层复制则不会。</p></li><li><p>如何在python中实现多线程？<br>可以通过导入threading模块来实现。（但我没试过，不知道效果咋样）</p></li><li><p>在python中编译和链接的过程是什么？<br>编译：python中的源代码保存为.py文件，然后将其编译为称为字节码的格式，然后将字节码转换为机器码。编译后，代码存储在.pyc文件中，并在更新源代码时重新生成。此过程称为编译；<br>链接：链接是最后一个阶段，其中所有功能都与它们的定义链接在一起，因为链接器知道在哪里实现所有这些功能。此过程称为链接。<br>在python中编译和链接允许正确编译新扩展而不会出现任何错误，并且只有在通过编译过程时才能进行链接。如果使用动态加载，则它取决于系统提供的样式。</p></li><li><p>什么是python库？<br>python库是python软件包的集合。如numpy，pandas，matplotlib，scikit-learn等。</p></li><li><p>拆分的用途是什么？<br>split（）用于分割给定的字符串。</p></li><li><p>在python中如何导入模块？<br>使用关键字import导入，有三种方式导入：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> array <span class="keyword">as</span> arr</span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></li><li><p>dict 的 items() 方法与 iteritems() 方法的不同？</p><p>items方法将所有的字典以列表方式返回，其中项在返回时没有特殊的顺序；</p><p>iteritems方法有相似的作用，但是返回一个迭代器对象</p></li><li><p>说明OS，sys模块的不同，并列举常用的模块方法</p><p>os：提供了一种方便的使用操作系统的方法</p><p>sys：可供访问由解释器使用或维护的变量和与解释器进行交互的函数</p><p>总结：os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。</p><p>os常用方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.remove(‘path/filename’) #删除文件</span><br><span class="line">os.rename(oldname, newname) #重命名文件</span><br><span class="line">os.walk() #生成目录树下的所有文件名</span><br><span class="line">os.chdir(&#x27;dirname&#x27;) #改变目录</span><br><span class="line">os.mkdir/makedirs(&#x27;dirname&#x27;) #创建目录/多层目录</span><br><span class="line">os.rmdir/removedirs(&#x27;dirname&#x27;) #删除目录/多层目录</span><br><span class="line">os.listdir(&#x27;dirname&#x27;) #列出指定目录的文件</span><br><span class="line">os.getcwd() #取得当前工作目录</span><br><span class="line">os.chmod() #改变目录权限</span><br><span class="line">os.path.basename(‘path/filename’) #去掉目录路径，返回文件名</span><br><span class="line">os.path.dirname(‘path/filename’) #去掉文件名，返回目录路径</span><br><span class="line">os.path.join(path1[,path2[,...]]) #将分离的各部分组合成一个路径名</span><br><span class="line">os.path.split(&#x27;path&#x27;) #返回( dirname(), basename())元组</span><br><span class="line">os.path.splitext() #返回 (filename, extension) 元组</span><br><span class="line">os.path.getatime\ctime\mtime #分别返回最近访问、创建、修改时间</span><br><span class="line">os.path.getsize() #返回文件大小</span><br><span class="line">os.path.exists() #是否存在</span><br><span class="line">os.path.isabs() #是否为绝对路径</span><br><span class="line">os.path.isdir() #是否为目录</span><br><span class="line">os.path.isfile() #是否为文件</span><br></pre></td></tr></table></figure><p>sys常用方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys.argv #命令行参数List，第一个元素是程序本身路径</span><br><span class="line">sys.modules.keys() #返回所有已经导入的模块列表</span><br><span class="line">sys.exc_info() #获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息</span><br><span class="line">sys.exit(n) #退出程序，正常退出时exit(0)</span><br><span class="line">sys.hexversion #获取Python解释程序的版本值，16进制格式如：0x020403F0</span><br><span class="line">sys.version #获取Python解释程序的版本信息</span><br><span class="line">sys.maxint #最大的Int值</span><br><span class="line">sys.maxunicode #最大的Unicode值</span><br><span class="line">sys.modules #返回系统导入的模块字段，key是模块名，value是模块</span><br><span class="line">sys.path #返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line">sys.platform #返回操作系统平台名称</span><br><span class="line">sys.stdout #标准输出</span><br><span class="line">sys.stdin #标准输入</span><br><span class="line">sys.stderr #错误输出</span><br><span class="line">sys.exc_clear() #用来清除当前线程所出现的当前的或最近的错误信息</span><br><span class="line">sys.exec_prefix #返回平台独立的python文件安装的位置</span><br><span class="line">sys.byteorder #本地字节规则的指示器，big-endian平台的值是&#x27;big&#x27;,little-endian平台的值是&#x27;little&#x27;</span><br><span class="line">sys.copyright #记录python版权相关的东西</span><br><span class="line">sys.api_version #解释器的C的API版本</span><br><span class="line">sys.stdin,sys.stdout,sys.stderr</span><br></pre></td></tr></table></figure></li><li><p>Python里面如何拷贝一个对象？deepcopy 和 copy的区别？</p><p>copy: 仅拷贝对象本身，而不拷贝对象中引用的其它对象;</p><p>deepcopy: 除拷贝对象本身，而且拷贝对象中引用的其它对象。</p></li><li><p>os.path和sys.path的区别？</p><p>os.path是module，包含了各种处理长文件名(路径名)的函数；</p><p>sys.path是由目录名构成的列表，Python 从中查找扩展模块( Python 源模块, 编译模块,或者二进制扩展)。 启动 Python 时,这个列表从根据内建规则,PYTHONPATH 环境变量的内容, 以及注册表( Windows 系统)等进行初始化。</p></li><li><p>re模块中match和search方法的不同？</p><p>match() 函数只检查 RE 是否在字符串开始处匹配，而search() 则是扫描整个字符串。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">print(re.match(&#x27;super&#x27;, &#x27;superstition&#x27;).span()) #检查super在字符串superstition中是否匹配，因为superstition中的super字符串在开头，此时，返回super在superstition中的起止位置；.span（）返回一个包括匹配的起止位置元组</span><br><span class="line">(0,5)</span><br><span class="line">print(re.match(&#x27;super&#x27;,&#x27;insuperable&#x27;)) #因为super不在insuperable的开头，所以返回none</span><br><span class="line">None</span><br><span class="line">print(re.search(&#x27;super&#x27;,&#x27;superstition&#x27;).span())</span><br><span class="line">(0,5)</span><br><span class="line">print(re.search(&#x27;super&#x27;,&#x27;insuperable&#x27;).span())</span><br><span class="line">(2,7)</span><br></pre></td></tr></table></figure></li><li><p>解释生成器(generator)与函数的不同，并实现和使用简单generator？</p><p>生成器和函数的主要区别在于函数 return a value，生成器 yield a value同时标记或记忆point of the yield 以便于在下次调用时从标记点恢复执行。 yield 使函数转换成生成器，而生成器反过来又返回迭代器。生成器的优点在于处理比较大的列表时节约内存。</p><p>利用函数生成Fibonacci系列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun(max): n为数量</span><br><span class="line">    a=[]</span><br><span class="line">    a.append(0)</span><br><span class="line">    a.append(1)</span><br><span class="line">    for i in range(max-2):</span><br><span class="line">        a.append(a[-1]+a[-2])</span><br><span class="line">    return a</span><br><span class="line">#主函数</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">for m in fun(10):</span><br><span class="line">    print(m,end=&quot; &quot;)</span><br></pre></td></tr></table></figure><p>利用生成器生成Fibonacci系列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun(max):</span><br><span class="line">n1=0 #第一个值</span><br><span class="line">n2=1 #第二个值</span><br><span class="line">num=0 #记录数量</span><br><span class="line">while num&lt;max:</span><br><span class="line">yield n1</span><br><span class="line">n1,n2=n2,n1+n2</span><br><span class="line">num+=1</span><br><span class="line">#主函数</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">for n in fun(10):</span><br><span class="line">print(n,end=&quot; &quot;)</span><br></pre></td></tr></table></figure></li><li><p>解释一下 WSGI 和 FastCGI 的关系？</p><p>CGI全称是“公共网关接口”(CommonGateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。</p><p>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute模式)。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</p><p>FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。</p><p>WSGI的全称为： PythonWeb Server Gateway Interface v1.0 （Python Web 服务器网关接口），</p><p>它是 Python 应用程序和 WEB 服务器之间的一种接口。</p><p>它的作用，类似于FCGI 或 FASTCGI 之类的协议的作用。</p><p>WSGI 的目标，是要建立一个简单的普遍适用的服务器与 WEB 框架之间的接口。</p><p>Flup就是使用 Python 语言对 WSGI 的一种实现，是可以用于 Python 的应用开发中的一种工具或者说是一种库。</p><p>Spawn-fcgi是一个小程序，这个程序的作用是管理fast-cgi进程，那么管理wsgi进程也是没有问题的，功能和php-fpm类似。</p><p>故，简单地说，WSGI和FastCGI都是一种CGI，用于连接WEB服务器与应用程序，而WSGI专指Python应用程序。而flup是WSGI的一种实现，Spawn-fcgi是用于管理flup进程的一个工具，可以启动多个wsgi进程，并管理它们。</p></li><li><p>解释一下 Django 和 Tornado 的关系、差别（待解决）</p></li></ol><h2 id="OOPS面试问题"><a href="#OOPS面试问题" class="headerlink" title="OOPS面试问题"></a>OOPS面试问题</h2><ol><li><p>用一个例子解释python中的继承。</p><p> 继承允许一个类获取另一个类的所有成员（如属性和方法）。继承提供了代码可重用性，使创建和维护应用程序变得更加容易。我们继承的类称为超类，而继承的类称为派生/子类。</p><p> python支持的不同类型继承：</p><ol><li>单一继承：派生类获取某个超类的成员</li><li>多级继承：从基类base1继承的派生类的d1和从base2继承的d2</li><li>层级继承：从一个基类可以继承任意数量的子类</li><li>多重继承：派生类继承自多个基类</li></ol></li><li><p>如何在python中创建类？</p><p> 使用关键字class创建</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ssp</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,sex</span>):<span class="comment">#self代表类的实例，是通过类创建的实例</span></span><br><span class="line">self.name=name</span><br><span class="line">self.age=age</span><br><span class="line">self.sex=sex</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;姓名:&#123;0&#125;;年龄:&#123;1&#125;;性别:&#123;2&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;sex&quot;</span>))</span><br><span class="line">ssp=ssp(<span class="string">&quot;ssp&quot;</span>,<span class="string">&quot;24&quot;</span>,<span class="string">&quot;man&quot;</span>)</span><br><span class="line">ssp.name</span><br><span class="line"><span class="string">&#x27;ssp&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>python中的猴子补丁是什么？</p><p>  在Python中，术语“猴子补丁”仅指运行时对类或模块的动态修改。</p></li><li><p>python是否支持多重继承？</p><p> 多重继承意味着一个类可以从多个父类派生，python支持多重继承。</p></li><li><p>什么是python中的多态？</p><p> 多态性是指采取多种形式的能力。例如，如果父类具有一个名为ABC的方法，则子类也可以具有一个具有相同名称和参数的ABC方法。Python允许多态。</p></li><li><p>在python中定义封装？</p><p> 封装意味着将代码和数据绑定在一起。</p></li><li><p>如何在python中进行数据抽象？</p><p> 在python中可以使用接口和抽象类来实现。</p></li><li><p>python是否使用访问说明符？</p><p> 否！python不会剥夺对实例变量或函数的访问权限。python提出了在变量，函数或方法的名称前加上单下划线或双下划线的概念，类似于保护和私有访问说明符。</p></li><li><p>如何在python中创建一个空类？</p><p> 空类是在其块内未定义任何代码的类，可以使用空语句pass来创建。</p></li><li><p>object（）有什么作用？</p><p>返回一个无特征的对象，该对象是所有类的基础，而且，它不带任何参数。</p></li></ol><h2 id="基本的python程序"><a href="#基本的python程序" class="headerlink" title="基本的python程序"></a>基本的python程序</h2><ol><li><p>用python编写程序执行冒泡排序算法。</p><p> 冒泡算法：一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maopao</span>(<span class="params">a</span>):</span><br><span class="line"><span class="built_in">len</span>=<span class="built_in">len</span>(a)<span class="comment">#获取列表的长度</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[i]&gt;a[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment">#c=a[i]</span></span><br><span class="line">                <span class="comment">#a[i]=a[i+1]</span></span><br><span class="line">                <span class="comment">#a[i+1]=c</span></span><br><span class="line">                a[i],a[i+<span class="number">1</span>]=a[i+<span class="number">1</span>],a[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></li><li><p>用python编写程序生成星型三角形。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def sjx(a):#a为三角形层数</span><br><span class="line">for i in range(a):</span><br><span class="line">print(&#x27; &#x27;*(a+1-i)+&#x27;*&#x27;*(2*i+1))</span><br><span class="line">sjx(9)</span><br></pre></td></tr></table></figure></li><li><p>编写程序用python生成Fibonacci系列。</p><p> Fibonacci系列：由0和1开始，之后的费波那契系数就由之前的两数相加。首几个费波那契系数是：0，1，1，2，3，5，8，13，21……</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=[]</span><br><span class="line">b=int(input())#生成多少个</span><br><span class="line">a.append(0)</span><br><span class="line">a.append(1)</span><br><span class="line">for i in range(b-2):</span><br><span class="line">a.append(a[-1]+a[-2])</span><br><span class="line">print(a) </span><br></pre></td></tr></table></figure><ol start="4"><li><p>用python编写程序检查数字是否为质数。</p><p> 质数：一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。质数p的约数只有两个：1和p。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a= int(input()) </span><br><span class="line">b=0</span><br><span class="line">for i in range(2,a-1):</span><br><span class="line">if a/i==int(a/i):</span><br><span class="line">b+=1</span><br><span class="line">else:</span><br><span class="line">b+=0</span><br><span class="line">if b==0:</span><br><span class="line">print(yes)</span><br><span class="line">else:</span><br><span class="line">print(no)</span><br></pre></td></tr></table></figure></li><li><p>用python编写程序以检查序列是否是回文。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=input()</span><br><span class="line">b=a[::-1]</span><br><span class="line">if a==b:</span><br><span class="line">print(yes)</span><br><span class="line">else:</span><br><span class="line">print(no)</span><br></pre></td></tr></table></figure></li><li><p>编写一个单行，将计算文件中大写字母的数量。即使文件太大而无法容纳在内存中，您的代码也应该可以工作。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f=open(&quot;lujing&quot;,&#x27;r&#x27;)</span><br><span class="line">a=f.readlines()</span><br><span class="line">count=0</span><br><span class="line">for i in a:</span><br><span class="line">for j in i:</span><br><span class="line">if j.isupper():</span><br><span class="line">count+=1</span><br><span class="line">##转换为单行</span><br><span class="line">count sum(1 for i in a for j in i if j.isupper())</span><br></pre></td></tr></table></figure></li><li><p>用python为数字数据集编写排序算法</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=input()</span><br><span class="line">c=a</span><br><span class="line">b=[]</span><br><span class="line">for in in range(len(a)-1):</span><br><span class="line">b.append(c.min())</span><br><span class="line">c.remove(c.min())</span><br><span class="line">b.append(a.max())</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大厂复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python学习、大厂面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网搭建方法</title>
      <link href="/2022/07/18/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/18/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>声明：为了自主维护国内网络环境安全，请大家在享受上网的快乐时能够恪守好自己的底线，不要干违法犯罪的事情。谨记一条：要想人不知，除非己莫为！！！不要到了最后才追悔莫及。我们坚信：网络永远都不是法外之地。</strong></p><h2 id="为什么要“科学上网”？"><a href="#为什么要“科学上网”？" class="headerlink" title="为什么要“科学上网”？"></a>为什么要“科学上网”？</h2><h3 id="有感而发"><a href="#有感而发" class="headerlink" title="有感而发"></a>有感而发</h3><p>众所周知，国内外网络之间有一堵“墙”的存在，那也是我们很多时候不能直接访问国外网站的根本原因。首先，对于普通人来说，这堵“墙”的存在根本不影响我们正常的上网需求。在此，我必须声明一点：国外的月亮并没有我们想象的那么圆！！！国外的网络上并没有特别稀奇古怪的东西，反而偏见到显得很严重（就我自己所看到的而言，外面充斥着各种反华言论，而且里面的论据绝大部分都是他们捏造和凭空想象的，因此去看完全是玷污自己的眼球和三观，纯属自己给自己找恶心！！！虽然国内有着很多待发展和完善的地方，但我们要站在自己国家的立场上想想，外面的世界是残酷的，人与人是这样，国与国也更是这样。作为我们普通人来说，我们还可以找一个真心朋友说说真心话，但国与国之间只有利益。而在利益面前，只有强大才是永恒的真理。所以国家为了更好地保护好我们，只有让自己不断变得更加强大。而在变强的过程中，她是孤独的，也肯定会犯一些错误。然而，作为她的儿女，我们必须得对自己国家多一点宽容和时间，通过正规渠道及时帮她纠正错误，共同缔造属于中华民族的神话!!!</p><h3 id="翻过去有什么用？"><a href="#翻过去有什么用？" class="headerlink" title="翻过去有什么用？"></a>翻过去有什么用？</h3><p>首先，如果能够实现“科学上网”，你能浏览国外大部分网站（国内网站已经做的很好了，基本需求都可以被满足，国外也没有比国内好多少，外国的月亮并不比国内的圆）。本人由于学习需要，需要经常上<a href="%5BGitHub%5D(https://github.com/)">Github</a>上面去学习（搬运）代码，为了学习过程更加流畅和稳定，就产生了翻“墙”的需求。市面上虽然会有很多“梯子”售卖，但大多不稳定和不安全，因此，本人开始学习自己搭建梯子。本文是一个分享贴，也是自我学习的记录贴（其中记载了自己趟过的不少坑）。话不多说，咱们直接开始。</p><h1 id="如果搭建属于自己的“梯子”？"><a href="#如果搭建属于自己的“梯子”？" class="headerlink" title="如果搭建属于自己的“梯子”？"></a>如果搭建属于自己的“梯子”？</h1><p>首先，搭建属于自己的“梯子”需要下列几步：</p><ol><li><a href="#%E8%B4%AD%E4%B9%B0VPS%EF%BC%88%E5%9B%BD%E5%A4%96%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89">购买VPS（国外服务器）</a></li><li><a href="#%E8%B4%AD%E4%B9%B0%E5%9F%9F%E5%90%8D">购买域名</a></li><li><a href="#%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%EF%BC%89">部署环境（服务器端）</a></li><li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE">使用“梯子”（客户端）</a></li></ol><h2 id="购买VPS（国外服务器）"><a href="#购买VPS（国外服务器）" class="headerlink" title="购买VPS（国外服务器）"></a>购买VPS（国外服务器）</h2><p>我们需要购买一台服务器搭载我们的“梯子“项目。为了更加方便地完成项目，我们建议直接购买”墙“外的服务器（推荐香港）。然而现在服务器商也有很多，因此同等配置下，不同服务器商的价格也大不相同。怎么去选适合自己的就因人而异，不过我们建议新手还是选择国内大品牌的(理由很简单，实在折腾不成功可以申请退款，退款快也方便，这一点就很帅)。配置的话，我建议新手选个低配先玩玩就行，后面看需求升级配置，系统我选的（CentOS）。</p><p>购买完服务器后在服务器商的控制台上找到所购买的服务器，需要使用远程登陆软件（我使用的putty，进入<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">putty官网</a>下载安装即可）（备注，建议先在控制台重置密码，重置密码后直接使用putty连接服务器即可</p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>为了更好地伪装我们的”梯子“，我们需要购买一个国内的域名（国外的价格贵，流程麻烦，转回国内还需要一大笔钱，别问我是怎么知道的，我只知道我的钱包又空了一大截），建议直接在同一服器商下购买，他会赠送一些服务，后面会省不少事。追求性价比的选个便宜的就行，一般10块左右就可以买一年了，相当便宜了。</p><p>购买完域名进入直接在控制台搜索DNS解析，然后进入选择添加域名，输入你所购买的域名，然后确定。然后选中你的域名，点击解析，不同服务器商弹出来的页面可能不一致，不过通常都是使用DNSPod解析或云解析，随便选一个就行点进去，然后选择快速添加解析，选择网站解析，网站地址中选择轻量应用服务器，输入你的服务器ip就行。最好接下来点一下ssl跟着提示正常提示申请一下ssl证书，选择免费证书就行。</p><h2 id="部署环境（服务器端）"><a href="#部署环境（服务器端）" class="headerlink" title="部署环境（服务器端）"></a>部署环境（服务器端）</h2><p>使用putty连接上服务器，具体怎么连接百度一下就行，过程贼简单，这就不多赘述。连上服务器后，我们可以跟着V2ray官网<a href="https://www.v2ray.com/">Project V · Project V 官方网站 (v2ray.com)</a>（不过被”墙了，需要通过“科学上网”的方式才能查看），不过接下来我会介绍主要的流程。</p><h3 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h3><p>这个很重要，建议一开始就进行，将服务器时间设为北京时间。具体做法为，在putty中输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date 查看当前服务器时间</span><br><span class="line">yum -y install nptdate  安装nptdate</span><br><span class="line">ntpdate -u 210.72.145.44  同步时间，210.72.145.44：中国国家授时中心的官方服务器</span><br><span class="line">date  查看修改后的时间是否为你电脑一致</span><br></pre></td></tr></table></figure><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>安装相关依赖软件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum makecache</span><br><span class="line">yum install curl</span><br></pre></td></tr></table></figure><p>下载主程序安装脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh</span><br></pre></td></tr></table></figure><p>执行安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash install-release.sh</span><br></pre></td></tr></table></figure><p>等待安装结束，期间可能会有各种错误出来。本人建议把错误直接复制到百度即可解决绝大部分错误，本人亲测方便有效。解决完错误再重新安装就行，这个过程有可能是短暂的，有可能是煎熬的。安装成功后会出现以下界面，到这，恭喜你，成功一大半了。</p><p><img src="/./%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/1.png"></p><p>运行v2ray</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start v2ray</span><br><span class="line">systemctl enable v2ray 设置开机自启动</span><br></pre></td></tr></table></figure><p>查看v2ray是否运行成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status v2ray</span><br></pre></td></tr></table></figure><p>出现以下界面即可运行成功，特别注意显示Active :active(running)才是正常运行状态</p><p><img src="/./%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/2.png"></p><h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><p>输入命令行<code>v2ray</code>即可出现下列界面，然后输入对应的数字即可完成对应的命令!</p><p><img src="/./%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/3.png"></p><p>我们选择修改 V2Ray 配置中的修改 V2Ray 传输协议，然后选择其中一种协议即可（并不是所有的协议都可用，这里建议多试几个），具体操作就是输入2–&gt;2–&gt;输入你选择的协议数字</p><p>选择好协议后输入<code>v2ray  URL</code>,即可生成url，把它复制下来，后面有用</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>进入v2ray官网<a href="https://www.v2ray.com/awesome/tools.html">神一样的工具们 · Project V 官方网站 (v2ray.com)</a>下载V2RayN，或者直接百度下载V2RayN应该也可以。下载后解压到一个文件夹，找到文件夹内的v2rayn.exe文件，双击打开，在左上角服务器栏选择从剪切板导入批量URL，导入后你就能查看你的服务器了，然后在主界面选中你的服务器，右键选择测试服务器速度，如果后面显示出有网速，那么恭喜你，大功告成了！右键v2ray小图标，选择服务器，选择自动配置系统代理就可以“科学上网”了。（每次退出的时候记得清除系统代理）</p><p>（plus：手机端也可以使用，下载v2rayNG安装到手机，然后也是导入URL就行）</p><p>避坑建议：</p><ol><li>测试服务器网速时显示0M/s，去前面更换协议就行，多试几个</li><li>在购买的服务器上把常用的端口都打开，具体做法百度以下就行，很简单，在域名管理里面的防火墙设置里面</li><li>实在搞不出来的可以多看看其他博客，相互映照，也可以给自己放个假，隔两天再来。不要害怕失败，我当初也是搞了十几天才成功搭建出来的，当初我也是一个纯小白入手，遇到的坑数不胜数，回想起来都一脸辛酸泪呀，不过这个过程还是很有意义的，很能锻炼我们自主学习的能力的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 自主学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> self-learning、科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+butterfly博客学习</title>
      <link href="/2022/07/14/hexo+butterfly%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/14/hexo+butterfly%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分：完成一个博客上传"><a href="#第一部分：完成一个博客上传" class="headerlink" title="第一部分：完成一个博客上传"></a>第一部分：完成一个博客上传</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先的在一个空文件夹里面初始化hexo环境，具体做法：点开空文件夹，鼠标右键点击git bash here，然后输入命令 hexo init和hexo install即可完成环境初始化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">hexo install</span><br></pre></td></tr></table></figure><h2 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h2><p>完成初始化后我们转到所在目录即可进行接下来的操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd +目录名</span><br></pre></td></tr></table></figure><p>接下来我们新建一个博客，输入命令“hexo new 第一篇博客”即可生成初始文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new 第一篇博客</span><br></pre></td></tr></table></figure><h2 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h2><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: test</span><br><span class="line">date: 2022-07-14 16:53:45</span><br><span class="line">tags: self-learning </span><br><span class="line">categories:</span><br><span class="line">- learning</span><br><span class="line">---</span><br><span class="line">摘要名称</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">接下来是文章摘要的正文内容</span><br></pre></td></tr></table></figure><p>包括博客里面重要的内容，如题目、作者、分类、标签等，这里需要注意的是空格，即在标点后面需要添加空格，如冒号： 空格 。这部分还可以添加文章的摘要，添加格式如上所述。</p><h3 id="资源引用"><a href="#资源引用" class="headerlink" title="资源引用"></a>资源引用</h3><p>当引用图片或其他形式的资源等，有以下两种方式解决：</p><p>1.使用绝对路径引用</p><p>2.使用相对路径引用</p><p>使用相对路径引用资源的时候，我们可以使用hexo提供的资源文件夹功能。</p><p>打开根目录下的_config.yml文件,将post_asset_folderde的值设为true</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>修改之后会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 <code>hexo new &lt;title&gt;</code> 命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。例如，你把一个 <code>example.jpg</code> 图片放在了这个同名文件夹中，使用相对路径的常规 markdown 语法 <code>![](./example.jpg)</code>即可访问 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](./式28.jpg)</span><br></pre></td></tr></table></figure><h2 id="文章上传"><a href="#文章上传" class="headerlink" title="文章上传"></a>文章上传</h2><h2 id="本地查看"><a href="#本地查看" class="headerlink" title="本地查看"></a>本地查看</h2><p>运行下列语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl或者hexo c或者hexo clean</span><br><span class="line">hexo g或者hexo generate(可省略)</span><br><span class="line">hexo s或者hexo server</span><br></pre></td></tr></table></figure><p>接下来访问它出现的<a href="http://localhost:4000/">网址</a>即可查看最新更改的内容</p><h2 id="上传GitHub"><a href="#上传GitHub" class="headerlink" title="上传GitHub"></a>上传GitHub</h2><p>运行下列语句即可完成上传</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl或者hexo c或者hexo clean</span><br><span class="line">hexo g或者hexo generate</span><br><span class="line">hexo d或者hexo deploy</span><br></pre></td></tr></table></figure><p>上传后有延迟，需要等待几分钟后刷新网页才会出现新更改的内容。</p><p>PLus：上传的时候用校园网一直上传不上去，改用手机热点即可上传成功！！</p><hr><h1 id="第二部分：文章加密"><a href="#第二部分：文章加密" class="headerlink" title="第二部分：文章加密"></a>第二部分：文章加密</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p><code>npm install --save hexo-blog-encrypt</code></p><h2 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h2><ol><li><p>首先在站点配置文件中启动该插件，即打开根目录下的_congfig.yml文件修改以下选项</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encrypt:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure></li><li><p>然后再在front-matter中添加对应的字段，如password，abstract，message等</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 文章加密</span><br><span class="line">date: 2019-01-04T22:20:13.000Z</span><br><span class="line">category: 教程</span><br><span class="line">tags:</span><br><span class="line">  - 博客</span><br><span class="line">  - Hexo</span><br><span class="line">keywords: 博客文章密码</span><br><span class="line">password: TloveY</span><br><span class="line">abstract: 密码：TloveY</span><br><span class="line">message:  输入密码，查看文章</span><br></pre></td></tr></table></figure><ul><li>keyword: 关键字</li><li>password：密码</li><li>abstract：文章摘要</li><li>message：博客查看时，密码输入框上面的描述性文字</li></ul><hr><h1 id="第三部分：更改主题"><a href="#第三部分：更改主题" class="headerlink" title="第三部分：更改主题"></a>第三部分：更改主题</h1><p>##butterfly<br>其实最好的使用提示就是查看其官方文档<a href="https://butterfly.js.org/">Butterfly</a></p><p>这里面已经很详细了，不过我在这还是简单地介绍一下大致流程可以帮我们更好地理解和使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>Git安装（GitHub）（稳定版）</p><p>在根目录下打开命令行或者右键选择Git Bash Here,接下来输入下列命令</p><p><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></p></li><li><p>Git安装（Gitee）（稳定版）</p><p>在根目录下打开命令行或者右键选择Git Bash Here,接下来输入下列命令</p><p><code>git clone -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</code></p></li></ol><p>3.npm安装<br>   在根目录下打开命令行或者右键选择Git Bash Here,接下来输入下列命令<br>   <code>npm i hexo-theme-butterfly</code></p><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改根目录下的_config.yml文件，把主题改为butterfly<br>   <code>theme:butterfly</code></p><h3 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h3><p>建议把这两条命令都运行一次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h3 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h3><p>在根目录下创建_config.butterfly.yml文件，并把themes文件夹下的butterfly子文件中的_congfig.yml内容复制到所创建的_config.butterfly.yml文件中去，注意这里的_config.yml文件不是根目录下的那个。完成后hexo会自动合并主题中的_config.yml文件和_config.butterfly.yml（优先级更高）文件中的配置</p><h3 id="主题使用建议pages"><a href="#主题使用建议pages" class="headerlink" title="主题使用建议pages"></a>主题使用建议pages</h3><p>详细阅读_config.butterfly.yml文件中的内容，里面重要的设置都有备注，不懂的地方可以跟着官方文档<a href="https://butterfly.js.org/posts/dc584b87/">butterfly</a>过一遍应该就差不多懂了</p><h1 id="自定义博客封面和背景"><a href="#自定义博客封面和背景" class="headerlink" title="自定义博客封面和背景"></a>自定义博客封面和背景</h1><p>有两种方式可以设置封面和背景，一种是在_congfig.butterfly.yml文件里修改，另一种是在每个博客的front-matter中定义，在这我推荐第二种方式，可以每篇文章设置不同的封面和背景</p><p>在front-matter中添加内容如下：</p><ul><li><p><code>top_img: 图片地址</code>  博客顶端背景</p></li><li><p><code>cover: 图片地址</code>文章封面</p></li></ul><h1 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h1><p>为了方便更好地访问我们的博客，我们可以在国内买一个域名（便宜的几块钱一年）绑定到我们的github上即可，具体步骤如下：</p><ol><li><p>在GitHub上打开你博客的所在项目，然后在setting–&gt;pages–&gt;custom domain输入你购买的域名，然后save即可</p></li><li><p>在根目录下的source文件夹下新建一个CNAME文件（没有后缀名），然后把你的域名填进去就行</p></li><li><p>修改根目录下的_config.yml文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render: CNAME</span><br></pre></td></tr></table></figure></li></ol><p>之后正常上传就好了</p>]]></content>
      
      
      <categories>
          
          <category> 自主学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> self-learning、博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
